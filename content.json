{"meta":{"title":"Rhyno Tech Blog","subtitle":null,"description":"Rhyno Tech Blog about agile, TDD, unit test, web development","author":"Rhyno park","url":"http://gregor77.github.io","root":"/"},"pages":[],"posts":[{"title":"React Testing Library를 이용한 Third party library 단위 테스트","slug":"react-testing-library-third-party-test","date":"2022-12-29T15:12:29.000Z","updated":"2022-12-29T21:10:58.644Z","comments":true,"path":"2022/12/30/react-testing-library-third-party-test/","link":"","permalink":"http://gregor77.github.io/2022/12/30/react-testing-library-third-party-test/","excerpt":"","text":"Jest와 React Testing Library를 사용하여 third-party 라이브러리 단위테스트의 어려움과 해결하는 사례를 공유한다. 개인적으로 최근까지 Vue기반 프론트엔드 개발을 하다가, 오랜만에 React를 사용하여 개발하고 있다. 예전에는 Enzyme를 사용하여 shallow render에서 단위 테스트를 진행했는데, 최근 React에는 Testing Libary를 사용하여 브라우저에서 동작하는 Full render 방식에서 단위 테스를 작성하는 것이 추세인 것 같다. (참고로, Enzyme은 글을 작성하는 현재 React 18을 지원하지 않고 있다.) 1. 게시글 등록 설명 연관글: React에서 Jodit Editor를 사용하여 게시판 만들기 앞서 Jodit Editor를 사용하여, 게시글을 등록하는 기능을 만들었는데, Jodit Editor를 감싼 Editor 컴포넌트를 만들었다. 1234567891011121314151617181920# Editor.jsconst handleChange = (htmlContents) =&gt; &#123; const plaintext = Jodit.modules.Helpers.stripTags(htmlContents); onChange(&#123; htmlContents, plainContents: plaintext, &#125;); &#125;; return ( &lt;JoditEditor ref=&#123;editor&#125; value=&#123;content&#125; config=&#123;config&#125; tabIndex=&#123;1&#125; // tabIndex of textarea onBlur=&#123;(newContent) =&gt; setContent(newContent)&#125; // preferred to use only this option to update the content for performance reasons onChange=&#123;handleChange&#125; /&gt; ); 게시판 등록 페이지(NewArticle.js)에서는 Editor 컴포넌트를 사용하여, onChange 이벤트 핸들러 함수(handleChangeContents)에서 에디터에서 변경된 html과 plainHtml을 전달받아 state로 관리한다. 저장 버튼을 클릭하면, 게시글 제목과 에디터에서 등록된 htmlContents, plainContents 내용을 가지고 신규 게시글을 등록한다. 123456789101112131415161718192021222324252627282930313233343536# NewArticle.jsexport default function NewArticle() &#123; const [contents, setContents] = useState(&#123; htmlContents: &#x27;내용을 입력하세요.&#x27;, plainContents: &#x27;&#x27;, &#125;); const handleChangeContents = (contents) =&gt; &#123; setContents(&#123; ...contents &#125;); &#125;; const addNewArticle = async () =&gt; &#123; const &#123; htmlContents, plainContents &#125; = contents; await bulletinBoardApi.addArticle(title, htmlContents, plainContents); &#125;; return ( &lt;PageContainer&gt; &lt;TitleContainer&gt; &lt;Title&gt;게시글 추가&lt;/Title&gt; &lt;/TitleContainer&gt; &lt;div className=&quot;new-article--container&quot;&gt; &lt;div className=&quot;new-article--editor-wrapper&quot;&gt; &lt;Editor html=&#123;contents.htmlContents&#125; onChange=&#123;handleChangeContents&#125; /&gt; &lt;/div&gt; &lt;ButtonGroupWrapper&gt; &lt;Button variant=&quot;outlined&quot; onClick=&#123;moveBack&#125;&gt; 취소 &lt;/Button&gt; &lt;Button variant=&quot;contained&quot; onClick=&#123;addNewArticle&#125;&gt; 저장 &lt;/Button&gt; &lt;/ButtonGroupWrapper&gt; &lt;/div&gt; &lt;/PageContainer&gt; 2. Third-pary 라이브러리의 Full render에서 테스트 어려움Jodit Editor의 onChange 이벤트를 실행하기 위해서, 내부적으로 Jodit Editor가 동작하는 방식을 확인해야 한다. Shallow render 방식에서는 Editor 컴포넌트를 찾고, 이벤트를 실행하면 간단하지만 Full render 방식에서는 Jodit editor가 어떻게 render되고, 그 안에서 onChange 이벤트를 실행하기 위한 동작 확인이 필요하다. (단순히 &lt;p&gt; 태그를 찾아서 innerHtml에 컨텐츠를 수정하는 방식으로는 onChange 이벤트가 실행되지 않았다.) Jodit Editor에서 onChange 이벤트를 실행해야만 NewArticle 페이지에서 컨텐츠 내용을 세팅할 수 있는데, 테스트를 작성하려는 대상인 SUT(System Under Test)에 집중해야 하는데 테스트 대상보다는 내부에 의존하고 있는 Third-party 라이브러리 분석에 시간이 오래 걸리는 상황이 단위 테스트 작성하기 어렵게 만들었다. 이런 문제를 해결하기 위해서 테스트 하기 쉬운 방법을 찾아야만 했다. Full render에서 Editor 컴포넌트 Mocking Testing Library는 그대로 사용 Jodit Editor를 감싼 Editor.js 컴포넌트를 Jest를 사용하여 Mocking 하기 Shallow render 방식에서 테스트 작성 Enzyme은 React 18 미지원 ‘react-test-renderer&#x2F;shallow’ 모듈을 사용한 shallow render Third-party 라이브러리르 사용하고 있는 컴포넌트 Mocking을 통해서 문제를 쉽게 해결할 수 있다. 따라서 Shallow render 방식으로 테스트 방식을 바꾸지 않고, Full render 방식의 테스트 일관성을 유지할 수 있다. 3. 테스트용 간접 컴포넌트 생성 및 Mocking을 통한 해결Editor.js 컴포넌트 대신에 단위 테스트용 간접 컴포넌트를 생성하여, Jest의 모듈 mocking 방식을 이용하여 Third-party 라이브러리의 내부 파악에 시간을 크게 들이지 않고, 쉽게 테스트 작성이 가능하다. 1234567891011121314151617181920# NewArticle.test.jsjest.mock(&#x27;@/components/editor/Editor&#x27;, () =&gt; &#123; // eslint-disable-next-line react/display-name return (&#123; html, onChange &#125;) =&gt; &#123; const handleChange = (e) =&gt; &#123; const htmlContents = e.target?.value; onChange(&#123; htmlContents, plainContents: NEW_PLAIN_CONTENTS, &#125;); &#125;; return &lt;input data-testid=&quot;editor&quot; value=&#123;html&#125; onChange=&#123;handleChange&#125; /&gt;; &#125;;&#125;);[참고] jest.mock 함수jest.mock(&#x27;모듈명&#x27;, factory 함수)- factory 함수 내부에서 테스트 목적의 함수형 컴포넌트를 리턴하게끔 한다. NewArticle.js 페이지 내부에서 Editor 컴포넌트를 사용하는데 jest.mock 함수를 사용하여 Editor 컴포넌트 대신에 테스트용 간접 컴포넌트를 사용하게끔 mocking이 가능하다. 또한 간접 컴포넌트에서 data-testid&#x3D;”editor” 값을 지정했기 때문에, screen.getByTestId(‘editor’)을 통해서 쉽게 가상 dom element를 접근이 가능하다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# NewArticle.test.jsjest.mock(&#x27;@/components/editor/Editor&#x27;, () =&gt; &#123; // eslint-disable-next-line react/display-name return (&#123; html, onChange &#125;) =&gt; &#123; const handleChange = (e) =&gt; &#123; const htmlContents = e.target?.value; onChange(&#123; htmlContents, plainContents: NEW_PLAIN_CONTENTS, &#125;); &#125;; return &lt;input data-testid=&quot;editor&quot; value=&#123;html&#125; onChange=&#123;handleChange&#125; /&gt;; &#125;;&#125;);describe(&#x27;NewArticle&#x27;, () =&gt; &#123; beforeEach(() =&gt; &#123; render( &lt;RecoilRoot&gt; &lt;NewArticle /&gt; &lt;/RecoilRoot&gt; ); &#125;); describe(&#x27;add newArticle&#x27;, () =&gt; &#123; const updateContents = async () =&gt; &#123; const editor = screen.getByTestId(&#x27;editor&#x27;); await fireEvent.change(editor, &#123; target: &#123; value: NEW_HTML_CONTENTS, &#125;, &#125;); &#125;; beforeEach(async () =&gt; &#123; bulletinBoardApi.addArticle.mockResolvedValue(); await updateContents(); const saveButton = screen.getByText(&#x27;저장&#x27;); fireEvent.click(saveButton); &#125;); it(&#x27;should add new article&#x27;, async () =&gt; &#123; expect(bulletinBoardApi.addArticle).toBeCalledWith(NEW_TITLE, NEW_HTML_CONTENTS, NEW_PLAIN_CONTENTS); &#125;); &#125;);&#125;); 마무리다른 화면에서 Editor 컴포넌트를 사용하는 경우에는 테스트용 간접 컴포넌트를 선언하고 Mocking 하는 방식을 개발자들이 반복해야 할 수 있다. 이런 문제를 해결하기 위해서 1) 테스트용 컴포넌트를 별도로 관리하고 2) 모듈 mocking하는 선언을 setupTest.js으로 이동하여 테스트 전체에 일괄로 적용한다. 이렇게 필요할 때마다 테스트용 간접 컴포넌트를 만들고, 글로벌 선언하는 방식을 차곡차곡 반복하면서, 케이스들이 쌓일 수록 개발자들은 단위 테스트 작성하기가 쉽고, 유지보수 하기 쉬운 테스트를 작성할 수 있다. 참고 How to test third-party components library in react-testing-library React Shallow render Test Jodit Editor Github 소스 testing libary - getByRole ARIA roles - getByRole 활용 Yarn berry 빌드 개선","categories":[{"name":"React, FE","slug":"React-FE","permalink":"http://gregor77.github.io/categories/React-FE/"}],"tags":[{"name":"React Testing Library, Unit Test, Jest","slug":"React-Testing-Library-Unit-Test-Jest","permalink":"http://gregor77.github.io/tags/React-Testing-Library-Unit-Test-Jest/"}]},{"title":"ElasticSearch - 인덱스","slug":"elasticsearch_index_shard","date":"2022-12-27T15:12:29.000Z","updated":"2022-12-28T05:26:40.404Z","comments":true,"path":"2022/12/28/elasticsearch_index_shard/","link":"","permalink":"http://gregor77.github.io/2022/12/28/elasticsearch_index_shard/","excerpt":"","text":"엘라스틱서치와 RDBMS 비교엘라스틱서치와 RDBMS에서 역할 비교를 통해서 의미를 파악한다. ElasticSearch RDBMS index database mapping schema document row 인덱스 (index) 문서가 저장되는 논리적인 공간 인덱스 설계가 첫단계 (예. 로그, 검색엔진) 인덱스 설계 방법인덱스 설계에 따라 문서의 구조 및 쿼리가 달라진다.하나의 인덱스로 시작해서, 사용자 패턴에 따라 점진적으로 확장해나간다. 하나의 인덱스 사용 관리해야 할 인덱스 수가 적어 관리가 쉽다. 쿼리, 문서 구조가 복잡성이 올라간다. 업무적으로 작은 단위로도 여러 개의 인덱스로 나눌때 최적화된 쿼리, 문서 구조 사용 가능 관리해야하는 인덱스가 많아지므로, 관리에 많은 비용이 든다. 샤드 (shard) 인덱스에 색인되는 문자가 저장되는 공간 샤드 종류 Primary Shard 문서가 저장되는 원본 샤드, 색인과 검색 성능에 영향 Replica Shard 프라이머리 샤드에 복제 샤드, 검색 성능에 영향 프라이머리 샤드 문제시, Replica Shard가 Primary Shard로 승격 샤드 설정 Primary Shard : 5개 Replica Shard &#x3D; number_of_shard * number_of_replicats &#x3D; 5 * 2 &#x3D; 10개 Total Shard : 5 + 10 &#x3D; 15개12345678PUT /library/_settings&#123; &quot;index&quot;: &#123; &quot;number_of_shards&quot; : 5, &quot;number_of_replicas&quot;: 2 &#125;&#125; 샤드 라우팅문서 저장되는 방법으로 샤드의 개수가 바뀌면, 문서가 저장되는 규칙이 완전히 바뀐다. Routing Rule &#x3D; (문서의 ID) % (샤드의 갯수) 인덱스 생성 시, 프라이머리 샤드의 갯수를 설정하는 것이 중요하다. 왜냐면 인덱스 생성 이후, 프라이머리 샤드 개수는 변경 불가하다. number_of_shards의 기본값 1로, 이 기본값을 그대로 사용하면 성능 문제가 발생한다. 인덱스 템플릿인덱스 템플릿을 통해 인덱스 생성 시의 샤드 개수를 미리 설정이 가능하다. 프라이머리 : 5, 레플리카 : 10, 총 15개1234567891011PUT _index_template// base_template&#123; &quot;index_pattern&quot;: [&quot;nginx-log-*&quot;], &quot;template&quot;: &#123; &quot;settings&quot;: &#123; &quot;number_of_shards&quot; : 5, &quot;number_of_replicas&quot;: 2 &#125; &#125;&#125;","categories":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"http://gregor77.github.io/categories/ElasticSearch/"}],"tags":[{"name":"ElasticSearch, 검색엔진","slug":"ElasticSearch-검색엔진","permalink":"http://gregor77.github.io/tags/ElasticSearch-%EA%B2%80%EC%83%89%EC%97%94%EC%A7%84/"}]},{"title":"React에서 Jodit Editor를 사용하여 게시판 만들기","slug":"jodit-editor-spiking","date":"2022-12-26T06:07:42.000Z","updated":"2022-12-26T15:10:02.281Z","comments":true,"path":"2022/12/26/jodit-editor-spiking/","link":"","permalink":"http://gregor77.github.io/2022/12/26/jodit-editor-spiking/","excerpt":"","text":"React 개발환경에서 오픈소스 Editor를 활용하여 게시판을 구현을 진행한다.아래 두가지 오픈소스 에디터 중, Jodit Editor를 선택하여 에디터 개발을 진행하기로 결정했다. Jodit Editor 라이센스 페이지 참고하여 오픈소스 or Pro버전 사용여부 결정 TOAST UI Editor 일부 Tag의 경우 파싱 에러가 발생하여 입력하지 못하도록 넣어줘야 한다는 개발자 경험이 존재 React Jodit Editor를 사용한 컴포넌트Jodit에 React 사용법 페이지를 참고하여, Editor 컴포넌트 생성 사용자 시나리오 게시글 목록 조회 게시글 목록은 Card view 형태로 목록이 조회된다. 게시글 내용은 Html tag가 제거된 채로 보여진다. 게시글 생성 제목, Editor에서 입력한 내용을 가지고 신규 게시글을 생성한다. 게시글 id, 제목, 내용을 Elastic Search에 저장한다. 게시글 상세조회 제목과 Editor로 등록한 html 내용을 보여준다. 게시글 제목, 내용을 통한 게시글 조회 개발시 참고1. 게시글 내용에서 Html 제거에디터에서 내용을 편집하면 기본적으로 tag가 포함된 내용을 text로 전달받는다. Html Tag가 제거된 게시글 내용이 필요한 이유? 게시글 목록 조회 시 Card view에서 태그가 제거된 내용 출력 검색 엔진(Elastic Search)으로 게시글 내용 조회 시, 태그가 제거된 내용을 ES에 저장 처음에는 서버에서 XSS Filter를 통해서 tag를 제거하는 방향으로 접근하려고 했으나, Jodit Helper 모듈에서 stringTags 함수를 통해서 태그가 제거된 텍스트를 구할 수 있다. 123456789101112131415161718const handleChange = (htmlContents) =&gt; &#123; const plaintext = Jodit.modules.Helpers.stripTags(htmlContents); onChange(&#123; htmlContents, plainContents: plaintext, &#125;); &#125;; return ( &lt;JoditEditor ref=&#123;editor&#125; value=&#123;content&#125; config=&#123;config&#125; tabIndex=&#123;1&#125; // tabIndex of textarea onBlur=&#123;(newContent) =&gt; setContent(newContent)&#125; // preferred to use only this option to update the content for performance reasons onChange=&#123;handleChange&#125; /&gt; ); 2. 게시글 내용(HTML) 출력하기div의 DOM Element에서 innerHtml로 값을 지정하는 경우, 게시글 내용을 표현할 수 있지만 XSS 공격에 쉽게 노출될 수 있기 때문에 위험하다. React에서는 직접 html을 설정할 수 있지만 위험하다는 것을 상기하기 위해서 dangerouslySetInnerHTML을 통해서 _html 키를 가지는 객체를 전달가능하다. 123&lt;div className=&quot;article-detail--contents-wrapper&quot;&gt; &lt;div className=&quot;article-detail--contents&quot; dangerouslySetInnerHTML=&#123;&#123; __html: htmlContents &#125;&#125; /&gt;&lt;/div&gt; 마무리검색엔진에서 게시글 내용으로 조회하기 위하여, Html tag를 제거한 plainContents를 게시글 id와 함께 Elastic Search에 저장하면 게시글 내용을 통한 검색이 가능할 것으로 예상된다. 참고 https://stackoverflow.com/questions/74611717/how-to-show-message-without-html-tags-which-is-take-from-joditeditor https://ko.reactjs.org/docs/dom-elements.html","categories":[{"name":"React, FE","slug":"React-FE","permalink":"http://gregor77.github.io/categories/React-FE/"}],"tags":[{"name":"Jodit, Editor","slug":"Jodit-Editor","permalink":"http://gregor77.github.io/tags/Jodit-Editor/"}]},{"title":"서평 - 인프라 엔지니어의 교과서","slug":"book-review-인프라엔지니어의교과서","date":"2021-06-11T00:39:56.000Z","updated":"2022-12-26T06:02:24.385Z","comments":true,"path":"2021/06/11/book-review-인프라엔지니어의교과서/","link":"","permalink":"http://gregor77.github.io/2021/06/11/book-review-%EC%9D%B8%ED%94%84%EB%9D%BC%EC%97%94%EC%A7%80%EB%8B%88%EC%96%B4%EC%9D%98%EA%B5%90%EA%B3%BC%EC%84%9C/","excerpt":"","text":"요즘에는 많은 서비스들을 퍼블릭 클라우드에 올려서, 개발자가 서비스 를 운영하기 좋은 상황이다. 그러다 보니 개발자가 고민하고 알아야하는 영역이 점차 확대되었고, 아키텍트와 개발자 역할자 간의 경계가 많이 사라졌다.개발자도 안정적인 서비스를 운영하기 위해서 고민과 경험을 하는 기회가 많아졌다. 책의 제목은 **인프라 엔지니어의 교과서, 요구사항 분석과 설계**이지만, 독자의 대상을 꼭 인프라 엔지니어로 제한할 필요는 없을 것 같다.소프트웨어 개발자 관점에서 이 책을 읽고 나서 느낀 점을 공유해보겠다. 누가 이 책을 읽으면 좋을까?운영 경험이 없는 개발자지금 회사는 개발과 운영 조직이 나누어져 있다. 개발 조직에서 일을 계속 하다보니, 운영 경험이 부족한 상황이다. 최근에 개발한 서비스를 직접 안정적으로 운영해야 하는 상황인데, 안정적인 서비스를 운영하기 위해서 어떤 준비가 필요한지 고민하게 되었다. 그런 상황에서 이 책을 접하게 되었고, 기존에 경험적으로 조각조각 알고 있었던 내용들을 다시 한번 정리할 수 있었다.특히 개인적으로 책에서 다음 내용이 만족스러웠다. 가용성을 위한 설계 - 부하분산 클러스터, HA 성능, 확장성을 위한 설계 - 스케일업, 스케일 아웃 운영, 유지보수를 위한 설계 - 백업, 모니터링 물론 이 책은 각 설계에 대한 이론적인 개념을 훑고 지나가는 정도이지, 이런 설계를 위해서 구체적으로 어떤 작업을 해야하는지 세세하게 알려주지는 않는다. 책을 읽어보고 고민해야하는 영역이 어딘지 키워드를 얻을 수 있지만, 그 이후에 구체적인 고민은 독자의 몫이다. 개발을 이제 시작한 사람들개발을 시작하고 몇년 동안을 돌아보면, 구현 관점에서 주로 새로운 방법들을 익히고, 성숙도를 높이는 방법에서만 고민을 했던 것 같다. 그러다보니 내가 개발한 서비스가 유지보수하기 좋고, 안정적으로 서비스를 운영하기 위해서 어떤 작업이 필요한지 까지는 생각이 확장되지 못했다. 개발하면서 이런 과정이 당연할 수도 있겠지만, 운영에서 어떤 일들이 필요한지 간접적으로라도 알 수 있다면 어플리케이션 영역안에서 개발하면서도 유지보수 하기 좋거나, 안정적인 운영을 위한 소프트웨어 개발을 고민할 수 있을 것 같다. 책을 읽기 전에 미리 알아둘 것요즘은 AWS, Google GCP등 퍼블릭 클라우드에서 서비스 운영을 하는 경우가 많다. 이 책은 퍼블릭 클라우드 기반에서 설명을 하거나 하지 않는다.엔터프라이즈 환경 또는 SI 프로젝트에서 내부에 서버 인프라를 사용하는 환경에서 인프라 엔지니어가 하는 일 위주로 설명이 되어있다. 소프트웨어 개발자가 본문에 하드웨어 관점에서 이중화, 확장성을 다루는 내용은 몰입이 떨어질 수 있다. 하지만 내용이 너무 깊게 다루어지거나 이런 것은 아니기 때문에 IT 교양 정보로 알아도 괜찮을 것 같다. 마무리책의 내용이 많은 편이 아니기 때문에 가볍게 읽을 수 있는 것이 이 책의 가장 큰 장점이다. 인프라 엔지니어 관점에서 안정적인 운영을 위해서 고민해야 하는 관점을 간접적으로 얻을 수 있는 것은 만족스럽다. 책의 구성이 딱딱한 글만 있는 것이 아니라, 다양한 그림과 이미지를 바탕으로 설명이 되어있어서 이해하기도 쉽고, 자연스럽게 읽히는 것도 좋았다. 마지막으로 자체적으로 서버를 구축하여 서비스를 운영하고 있는 팀에서 일하는 개발자라면 읽어봐도 좋을 것 같다. 운영 경험이 없는 상황에서 운영할 때 어떤 점을 고려해야 하는지 인사이트가 필요한 개발자라면 읽어보는 것을 추천한다.","categories":[{"name":"Review","slug":"Review","permalink":"http://gregor77.github.io/categories/Review/"}],"tags":[{"name":"인프라 엔지니어의 교과서","slug":"인프라-엔지니어의-교과서","permalink":"http://gregor77.github.io/tags/%EC%9D%B8%ED%94%84%EB%9D%BC-%EC%97%94%EC%A7%80%EB%8B%88%EC%96%B4%EC%9D%98-%EA%B5%90%EA%B3%BC%EC%84%9C/"},{"name":"요구사항 분석과 설계","slug":"요구사항-분석과-설계","permalink":"http://gregor77.github.io/tags/%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD-%EB%B6%84%EC%84%9D%EA%B3%BC-%EC%84%A4%EA%B3%84/"},{"name":"길벗","slug":"길벗","permalink":"http://gregor77.github.io/tags/%EA%B8%B8%EB%B2%97/"}]},{"title":"Spring Security - 3. 인증 절차를 정의하는 AuthenticationProvider","slug":"spring-security-03","date":"2021-05-18T06:37:17.000Z","updated":"2022-12-26T06:02:24.385Z","comments":true,"path":"2021/05/18/spring-security-03/","link":"","permalink":"http://gregor77.github.io/2021/05/18/spring-security-03/","excerpt":"","text":"Spring Security에서 어떻게 인증이 시작될까?Spring security는 내부에 인증 절차가 이미 구현되어 있다. spring security의 인증 절차를 이해하고 난다면, 구현체와 설정을 통해서 새로운 인증 절차를 추가할 수 있다. 이번 글을 통해서 아래 내용을 이해하자. Spring security 아키텍쳐 기반에서 인증 절차가 어떻게 진행되는가? 실습을 통해서 커스터마이징된 인증 절차 개발시 어떤 작업을 추가로 해야 하는가? 1. Spring security에서 인증절차 이해하기Spring security는 AuthenticationManager(ProviderManager)가 가지고 있는 provider 목록을 순회하면서 provider가 실행 가능한 경우에 provider의 authenticate 메소드를 호출하여 인증 절차를 수행한다. a. AuthenticationManagerAutheticationManager는 인증을 처리하는 방법을 정의한 API이다. AuthenticationFilter에 의해 AuthenticationManager가 동작한다. 인증을 처리하면 SecurityContextHolder에 Authentication 값이 세팅된다. b. ProviderManagerProviderManager는 AuthenticationManager의 가장 일반적인 구현체이다. ProviderManager는 AuthenticationProvider 목록을 위임 받는다.각 AuthenticationProvider는 인증 성공, 실패, 결정할 수 없음을 나타낼 수 있고, 나머지 AuthenticationProvider가 결정을 할 수 있도록 전달한다. 기본적으로 ProviderManager는 Authentication 성공적인 인증 요청이 반환하는 Authentication 객체에서 민감한 credential 정보를 삭제하려고 시도한다. 이렇게 하면 암호와 같은 정보가 HttpSession에서 오래 지속되는 것을 방지한다. 이런 방법은 stateless application에서 성능 향상을 위해서 user 객체를 cache에 사용할때 문제가 발생할 수 있다. Authentication에 cache에 있는 개체에 대한 참조가 포함되어 있고, 이 개체의 credential이 제거된 경우, 더 이상 cache 값에 대한 인증할 수 없다. 따라서 cache를 사용하는 경우 이 문제점을 인지하고, 캐시 구현 또는 반환된 인증 객체를 생성하는 AuthenticaionProvider에서 먼저 객체의 복사본을 만드는 것이다. 또는 ProviderManager의 eraseCredentialsAfterAuthentication 속성을 disable을 적용하라. 12345678910111213141516171819202122232425262728293031323334353637// spring-security-core.jar 원본 소스 참고 : ProviderManager 클래스의 authenticate 메소드public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123; Class&lt;? extends Authentication&gt; toTest = authentication.getClass(); AuthenticationException lastException = null; AuthenticationException parentException = null; Authentication result = null; Authentication parentResult = null; boolean debug = logger.isDebugEnabled(); for (AuthenticationProvider provider : getProviders()) &#123; if (!provider.supports(toTest)) &#123; continue; &#125; if (debug) &#123; logger.debug(&quot;Authentication attempt using &quot; + provider.getClass().getName()); &#125; try &#123; result = provider.authenticate(authentication); if (result != null) &#123; copyDetails(authentication, result); break; &#125; &#125; catch (AccountStatusException | InternalAuthenticationServiceException e) &#123; prepareException(e, authentication); // SEC-546: Avoid polling additional providers if auth failure is due to // invalid account status throw e; &#125; catch (AuthenticationException e) &#123; lastException = e; &#125; &#125;... c. AuthenticationProvider각각의 AuthenticationProvider는 특정 유형의 인증을 수행한다. id, password 기반 인증 경우 : username &#x2F; password 가 유효한지 검사 saml 기반 인증 경우 : saml assertion을 수행 후 authentication 리턴 2. 실습하기spring security 구현체에 대해서 알아보았으니, 아래 요건에 해당되는 실습을 해보자. 추후에 커스터마이징한 기능을 만들 상황에 대비해서, 직접 provider, token, filter를 각각 만들어보겠다.(참고 : DB 기반 id&#x2F;password 인증은 spring security의 DaoAuthenticationProvider을 사용하더라도 동작한다.) 구현체실습을 위해서 직접 생성한 구현체들에 prefix로 ‘Custom’을 붙여 네이밍한다. CustomAuthenticationProvider id, password 기반 인증 CustomAuthenticationToken email, credentials 포함하는 별도 token 생성 CustomAuthenticationFilter CustomAuthenticationToken을 사용하여 provider의 authenticate 메소드를 호출 특히, saml 인증 방식 사용하는 경우, 해당 필터에서 saml assertion을 진행 후 인증을 수행하는 provider 호출 WebSecurityConfig custom provider를 AuthenticationManager에 추가하는 설정 custom filter 설정 a. CustomAuthenticationProviderProvider 내부에서 하는일은?provider 내부에서 인증 절차를 수행할 뿐 아니라, 추가적으로 supports 메소드를 통해서 token 타입에 따라서 언제 provider를 사용할지 조건을 지정할 수 있다.실제 클래스명은 의도를 명확하게 하는 의미있는 명으로 naming 하는 것이 좋기 때문에 ‘Custom’ 대신에 프로젝트 keyword를 사용해도 좋다. provider 동작 여부supports 메소드를 override하여 provider의 동작 여부를 결정할 수 있다. 예제처럼 커스터마이징된 token을 사용하는 경우로 provider 동작조건은 제한함으로써 다른 인증 수행하는 provider에게 영향을 주지 않는다. CustomAuthenticationFilter에 attemptAuthentication 메소드 내부에서 token을 사용하여 provider를 호출하는 부분이 선언되어 있다. provider의 supports 값이 false를 리턴하면, provider의 authenticate 메소드가 호출되지 않는다. (참고 : ProviderManager 소스) 1234567891011121314151617181920212223242526272829303132@Componentpublic class CustomAuthenticationProvider implements AuthenticationProvider &#123; private final CustomUserDetailsService userDetailsService; private final SamplePasswordEncoder passwordEncoder; public CustomAuthenticationProvider(CustomUserDetailsService userDetailsService, SamplePasswordEncoder passwordEncoder) &#123; this.userDetailsService = userDetailsService; this.passwordEncoder = passwordEncoder; &#125; @Override public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123; String username = authentication.getName(); String password = (String) authentication.getCredentials(); UserDetails user = userDetailsService.loadUserByUsername(username); if (user == null) &#123; throw new BadCredentialsException(&quot;username is not found. username=&quot; + username); &#125; if (!this.passwordEncoder.matches(password, user.getPassword())) &#123; throw new BadCredentialsException(&quot;password is not matched&quot;); &#125; return new CustomAuthenticationToken(username, password, user.getAuthorities()); &#125; @Override public boolean supports(Class&lt;?&gt; authentication) &#123; return CustomAuthenticationToken.class.isAssignableFrom(authentication); &#125;&#125; 기본 인증 절차 16 Line provider 내부에서는 username을 가지고 사용자 정보를 조회 (UserDetailsService 호출) 실습에서는 username이 email 값이 입력된다. (CustomAuthenticationFilter 참고) 17 ~ 23 Line 사용자 정보가 유효한지 판단 유효하지 않은 경우 (예: 사용자 정보 존재하는지, 계정 잠김, 비밀번호 실패 초과), RuntimeException 발생 (예: BadCredentialException) 후 에러 응답 처리한다. id, password 기반 인증이라면, password가 일치하는지 25 Line AuthenticationToken에 사용자 정보(username, authorities)를 세팅한다. token 자체가 Authentication 객체이기 때문에, 이후에 SecurityContextHolder 내부 context 객체에 token 값이 저장되어 있다. b. CustomAuthenticationTokenspring security에 기본적으로 제공하는 token이 존재한다. (예: AnonymousAuthenticationToken, UsernamePasswordAuthenticationToken)spring security에서 제공하는 token 외에 추가적인 필드들을 가져야하는 경우 별도의 token을 생성해야 한다. 123456789101112131415161718192021222324public class CustomAuthenticationToken extends AbstractAuthenticationToken &#123; private String email; private String credentials; public CustomAuthenticationToken(String email, String credentials, Collection&lt;? extends GrantedAuthority&gt; authorities) &#123; super(authorities); this.email = email; this.credentials = credentials; &#125; public CustomAuthenticationToken(Collection&lt;? extends GrantedAuthority&gt; authorities) &#123; super(authorities); &#125; @Override public Object getCredentials() &#123; return this.credentials; &#125; @Override public Object getPrincipal() &#123; return this.email; &#125;&#125; 1 Line AbstractAuthenticationToken을 상속받는 custom token 클래스 생성. principal : 사용자를 식별할 수 있는 값 (예: id, email) credential : 일반적으로 비밀번호를 의미 인증을 통과하여 생성된 token은 SecurityContextHolder의 context로 부터 얻어올 수 있다. c. CustomAuthenticationFilter만약 provider의 supports 메소드의 리턴값을 항상 true로 해둔다면, 다른 인증방식을 수행할때도 provider가 동작하게 될 것이다. 따라서 이번 실습은 특정 CustomAuthenticationToken을 사용하는 경우에만 provider가 동작되게 설정했다. 인증을 수행하기 위한 별도의 provider를 생성했고, provider가 특정 token을 사용하는 경우에만 동작하도록 설정을 했다. 해당 filter에서 custom token을 가지고 provider를 실행하는 부분을 선언한다. 123456789101112131415public class CustomAuthenticationFilter extends AbstractAuthenticationProcessingFilter &#123; public CustomAuthenticationFilter(RequestMatcher requiresAuthenticationRequestMatcher) &#123; super(requiresAuthenticationRequestMatcher); &#125; @Override public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException, IOException, ServletException &#123; String email = request.getParameter(&quot;username&quot;); String credentials = request.getParameter(&quot;password&quot;); return getAuthenticationManager().authenticate(new CustomAuthenticationToken(email, credentials)); &#125;&#125; 8 Line AbstractAuthenticationProcessingFilter을 상속받아서 attemptAuthentication을 override 한다 예를 들어 saml 인증방식을 사용하는 경우 saml assertion을 수행 후, 통과하면 id 또는 email로 provider를 통해서 인증을 수행한다. 13 Line custom token을 사용하여 provider를 실행하는 부분을 정의한다. d. WebSecurityConfigWebSecurityConfig는 WebSecurityConfigurerAdapter을 상속받아 security 관련 설정을 관리하는 java config 클래스다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@Configuration@EnableWebSecurity@EnableGlobalMethodSecurity(prePostEnabled = true)public class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired private CustomUserDetailsService userDetailsService; @Autowired private SamplePasswordEncoder passwordEncoder; @Override protected void configure(HttpSecurity http) throws Exception &#123; http .csrf().disable() //csrf 비활성화하고자 하는 경우// .csrf()// .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())// .and() .addFilterAfter(customAuthenticationFilter(), CsrfFilter.class) .authorizeRequests() .antMatchers(&quot;/&quot;, &quot;home&quot;).permitAll() .anyRequest().authenticated() .and() .formLogin() .loginPage(&quot;/login&quot;) .permitAll() .and() .logout() .permitAll(); &#125; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.authenticationProvider(authenticationProvider()); &#125; @Bean public CustomAuthenticationFilter customAuthenticationFilter() throws Exception &#123; CustomAuthenticationFilter filter = new CustomAuthenticationFilter( new AntPathRequestMatcher(&quot;/api/v1/login&quot;, HttpMethod.POST.name()) ); filter.setAuthenticationManager(authenticationManagerBean()); filter.setAuthenticationSuccessHandler(new SimpleUrlAuthenticationSuccessHandler(&quot;/hello&quot;)); filter.setAuthenticationFailureHandler(new SimpleUrlAuthenticationFailureHandler(&quot;/login?error&quot;)); return filter; &#125; @Bean public AuthenticationProvider authenticationProvider() &#123; return new CustomAuthenticationProvider(userDetailsService, passwordEncoder); &#125; @Bean @Override public AuthenticationManager authenticationManagerBean() throws Exception &#123; return super.authenticationManagerBean(); &#125;&#125; 12 Line http 요청에 대한 security 설정 18 Line 인증을 위해 생성한 custom filter 적용, .addFilterAfter() 또는 .addFitlerBefore() 메소드를 사용하여 filter 실행 순서를 상대적으로 지정할 수 있다. 32 Line email &#x2F; password 기반 인증을 수행하는 custom provider를 AuthenticationManager에 등록 37 Line custom provider를 사용하여 인증을 진행하는 custom AuthenticationProcessingFilter를 선언하는 부분 “&#x2F;api&#x2F;v1&#x2F;login” 주소로 POST 요청이 오면 해당 filer 가 동작한다. 인증이 성공하면 “&#x2F;hello” 화면으로 redirect 인증이 실패하면 “&#x2F;login?error” 화면으로 redirect 3. 동작 확인start-security 프로젝트에서 resources&#x2F;db&#x2F;data.sql을 참고하면, 테스트 사용자 계정을 확인할 수 있다. 테스트 계정 1의 id&#x2F;password : &#x75;&#115;&#x65;&#x72;&#x31;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#x2F;1111 테스트 계정 2의 id&#x2F;password : &#117;&#115;&#x65;&#114;&#50;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x2F;2222 adamin 계정의 id&#x2F;password : &#97;&#100;&#x6d;&#x69;&#110;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x2F;3333 1. 로그인 시도 로그인 화면 주소 : http://localhost:8080/login 서버로 로그인을 위한 “&#x2F;api&#x2F;v1&#x2F;login” 주소로 POST 요청이 날아간다. 서버에서는 CustomAuthenticationFilter에서 CustomAuthenticationProvider을 통해서 email&#x2F;password 기반 인증을 처리한다. 2. 인증 성공시 filter의 successHandler에 따라 “&#x2F;hello” 화면으로 redirect 된다. session 정보가 있음을 화면을 통해서 확인 가능하다. 3. 인증 실패시 filter의 failureHandler에 따라 “&#x2F;login?error” 주소로 redirect 된다. 로그인 화면에서 error 문구(“”)가 출력되는 것을 확인 가능하다. 마치며이번 글을 통해서 Spring Security에서 어떻게 인증 절차가 시작되고 진행되는지 알아보았다.spring security 기반에서 별도의 인증 절차를 직접 구현하기 위해서, AuthenticationFilter AuthenticationManager (ProviderManager) AuthenticationProvider 각각의 역할에 대해서 꼭 기억하길 바란다. 참고 Rhyno Github 실습 Repository Spring Security - 2. Role과 권한(Privilege) Spring Security - 1. Authentication, SecurityContextHolder","categories":[{"name":"Spring security","slug":"Spring-security","permalink":"http://gregor77.github.io/categories/Spring-security/"}],"tags":[{"name":"Spring Security","slug":"Spring-Security","permalink":"http://gregor77.github.io/tags/Spring-Security/"},{"name":"인증 절차","slug":"인증-절차","permalink":"http://gregor77.github.io/tags/%EC%9D%B8%EC%A6%9D-%EC%A0%88%EC%B0%A8/"},{"name":"AuthenticationManager","slug":"AuthenticationManager","permalink":"http://gregor77.github.io/tags/AuthenticationManager/"},{"name":"ProviderManager","slug":"ProviderManager","permalink":"http://gregor77.github.io/tags/ProviderManager/"},{"name":"AuthenticationProvider","slug":"AuthenticationProvider","permalink":"http://gregor77.github.io/tags/AuthenticationProvider/"}]},{"title":"Spring Security - 2. Role과 권한(Privilege)","slug":"spring-security-02","date":"2021-04-21T07:40:17.000Z","updated":"2022-12-26T06:02:24.385Z","comments":true,"path":"2021/04/21/spring-security-02/","link":"","permalink":"http://gregor77.github.io/2021/04/21/spring-security-02/","excerpt":"","text":"Role과 권한을 조회하는 UserDetailsService이번 시간에는 SecurityContext에 보관되는 Authentication, Role과 권한(Authority 또는 Privilege)에 대해 알아보겠다.경험을 바탕으로 Role과 권한의 차이는 무엇이고, 실습 예제로 어떻게 Spring Security에서 GrantedAuthority를 관리하는지 알아보자. 이번 글을 통해서 아래 내용을 이해하자. Spring Security 기반 Role 과 권한 설계 사용자 정보를 조회하는 UserDetailsService 참고로 Spring Security에서 GrantedAuthority와 일반적인 권한을 의미하는 단어로 Authority를 사용하면 단어가 비슷해 혼란을 줄 수 있다고 생각한다.따라서 이하 본문에서는 권한을 Privilege로 표현하고, GrantedAuthority는 따로 설명을 진행하겠다. 1. Role과 권한(Privilege) 설계Spring Security에서 Role과 권한(Privilege)을 어떻게 설계해야 된다는 직접적인 가이드는 없다. 기존에 플젝에서 경험을 Spring Security - Roles and Privileges 아티클 기반으로 내용을 정리해본다. 권한 설계 작업은 언제하는 것이 좋은가?시스템에 따라 어떤 Role이 필요한지는 사용자 시나리오나 Persona 기반으로 도출할 수 있다.하지만 어떤 권한이 필요한지 정의를 할때는 사용자 시나리오나 User Journey Map기반으로 진행하면, 상상을 기반으로 하기때문에 구체적인 상황을 고려하려 설계를 진행하기 어렵다. 개인적으로 권한(Privilege) 설계는 시스템이 어느 정도 개발이 되고 나서, 실물 기반으로 시스템 권한, 비지니스별 권한 설계하는 것이 구체적인 상황별로 생각을 확장해서 고민할 수 있어서 더 편했던 것 같다. 장점 눈에보이는 구체적인 상황을 기준으로 설계를 진행할 수 있어서 쉽게 작업할 수 있다. 설계를 실물 기반으로 검증할 수 있어서 불확실성을 줄이고, 불필요한 작업을 할 확률을 줄인다. 단점 Role, 권한 설계가 소스, 테스트 포함해서 시스템 전반에 영향을 끼치기 때문에 작업 범위가 커서 시간이 오래 걸릴 수 있다. 작업 시점이 너무 늦지 않는 것이 중요하다. 작업 시점이 너무 늦으면 권한 설계로 인해 소스가 변경되야 하는 상황이 생기는데, 영향도가 크면 적용하기가 점점 어려워진다. a. RoleRole은 시스템에서 사용하는 사용자의 역할을 의미한다. Role은 동시에 두 가지형태로 사용될 수 있다. 그 자체로 권한으로 사용할 수 있다. 권한(Privilege)을 담는 Container로써 사용할 수 있다. b. 권한(Privilege)시스템에서 사용하는 low-level의 권한을 의미한다. 앞에서 설명한 것처럼 Role은 권한을 담는 Container로써 역할을 수행할 수 있기 때문에, 권한 설계시에는 Role이 사용할 수 있는 모든 권한이 도출되어 있어야 한다. Role과 Privilege 의 관계 : 다대다(N:N) 권한은 Role별로 그룹핑 되고 관리되는 대상이다. 논리적으로 권한(Privilege 또는 Authoritiy)이 Role보다 더 작고 세밀하다. c. Role과 권한(Privilege) 설계 예시이전의 플젝 경험을 바탕으로, Role과 권한 관계를 어떻게 설계할 수 있는지 예를 들어 확인해보자.Role가 권한(Privilege)은 시스템 전반에 영향을 끼치는 high-level 범위에서 설계가 되어야 한다. 사업부 체크와 같은 비지니스별 권한 체크는 여기서 제외하며, 추후에 구체적으로 다루도록 하겠다. “경영지표를 확인하는 대쉬보드 시스템”실적을 조회하는 대쉬보드 형태의 시스템이었고, Role은 일반 사용자와 사용자 관리를 할 수 있는 어드민 사용자로 구분이 되었다. ROLE_USER (일반 사용자) READ_AUTHORITY 만 가짐 ROLE_ADMIN (관리자) WRITE_AUTHORITY : 사용자 관리, 메뉴 관리(등록, 수정, 삭제) READ_AUTHORITY “프로젝트의 공정, 일감을 관리하는 시스템”누구나 사용을 할 수 있지만 회원가입을 한 최초 사용자는 “임시 사용자”로써 프로젝트 공지사항, 메일, 일정등 가장 기본적인 커뮤니케이션 기능만 사용할 수 있다.프로젝트 관리자가 승인을 해주면, “일반 사용자”로 역할이 변경되면서 프로젝트에서 상세한 공정, 일감, 요구사항 관리들의 기능을 수행할 수 있다.프로젝트의 어드민 관리 기능 (예. 메뉴, 사용자, 권한, 캘린더, 회의실)은 “관리자” 역할자만 변경이 가능했다. ROLE_TEMPORARY_USER (임시 사용자) 최초 회원가입하면 임시 사용자로써, 메일, 일정 관리등 커뮤니케이션 관련된 기능만 기본적으로 사용할 수 있음 COMMUNICATION_AUTHORITY : 메일 관리, 일정 관리 ROLE_USER (일반 사용자) 관리자가 승인을 해주면, 일반 사용자로 변경이 되고 COMMUNICATION_AUTHORITY 외에 추가적으로 공정, 일감 관리 기능까지 수행 가능 COMMUNICATION_AUTHORITY, WORK_AUTHORITY (공정 관리), TASK_AUTHORITY (일감 관리) ROLE_ADMIN (관리자) 관리자의 경우, 프로젝트가 생성되면 프로젝트 관리자 계정이 자동으로 생성됨 프로젝트 관리자 계정은 메뉴, 프로젝트 사용자, 권한 관리등 어드민성 기능을 수행할 수 있다. 기본적으로는 일반 사용자의 권한을 사용할 수 있으며, 추가적으로 설정 관리까지 수행 가능하다. CONFIG_AUTHORITY (설정 관리 - 메뉴, 사용자 관리 등등) 2. Spring Security 실습이전에는 Role과 권한 설계방법에 대해서 알아보았다면, 이제는 Spring Security에서는 Role과 권한 적용을 위해서 어떤 클래스를 사용할 지 알아보자.각 클래스별로 역할이 무엇인지 이해하고 있다면 구현하기 더 수월하다. 빨간색으로 표시된 부분이 이번 실습과 연관된 클래스이다. 실습 프로젝트의 구조와 실습과 관련된 클래스에 대해서 알아보자.Role과 권한 설계 예시에서 “프로젝트의 공정, 일감을 관리하는 시스템”의 내용을 사용하여 Unit Test 기반으로 실습을 진행한다. 실습 프로젝트 Github 주소 : https://github.com/gregor77/start-spring-security Spec : Java 8, Spring Boot, H2, Spring Web, Spring Data JPA, Lombok 목표 : Role과 권한 설계 내용을 바탕으로 Spring security에서 사용자의 Role과 권한(Previlege)을 UserDetailsService를 사용해서 조회하는 실습을 진행해보자. a. 프로젝트 설정실습 프로젝트는 H2 DB를 사용하여 구동된다. resources&#x2F;db&#x2F;data.sql 어플리케이션 샘플 데이터(User, Role, Privilege)를 생성하는 insert 쿼리 사용자 비밀번호는 bcrypt password encoder를 통해서 encoding 된 값이다. resources&#x2F;db&#x2F;schema.sql 어플리케이션을 수행하는데 필요한 테이블 생성 쿼리 resources&#x2F;templates&#x2F;login.html email과 password 기반의 로그인 화면 b. User, Role, Privilege Entity 객체 User 사용자 정보를 포함하는 entity 객체로 UserDetails의 구현체이다. User와 Role은 N:N 관계이다. Role 시스템에서 관리하는 Role 정보를 저장하는 entity 객체 Role은 Privilege의 컨테이너로써 역할을 수행하기 때문에 하나의 Role은 여러 개의 권한을 포함한다. Role과 Privilege의 관계는 N:N 관계이다. Role과 Privilege는 “role_privilege” 매핑 테이블을 통해서 관리된다. Privilege 시스템에서 관리하는 권한 정보를 저장하는 entity 객체 Role과 Privilege의 관계는 N:N 관계이다. c. UserDetails 인증된 핵심 사용자 정보 (권한, 비밀번호, 사용자명, 각종 상태)를 제공하기 위한 interface이다. 기존에 만들어진 시스템에 존재하는 User 클래스가 UserDetails의 구현체가 되면 된다. 추가적으로 시스템에서 사용자 관리 시나리오에 따라 isAccountNonExpired, isAccountNonLocked, isCredentialsNonExpired, isEnabled 구현하면 된다.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@Entity@Builder@Data@NoArgsConstructor@AllArgsConstructorpublic class User implements UserDetails &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; @Column private String name; @Column private String email; @Column private String password; @Column private String phoneNumber; @Transient private Collection&lt;SimpleGrantedAuthority&gt; authorities; @ManyToMany(fetch = FetchType.EAGER) @JoinTable( name = &quot;user_role&quot;, joinColumns = @JoinColumn(name = &quot;user_id&quot;, referencedColumnName = &quot;id&quot;), inverseJoinColumns = @JoinColumn(name = &quot;role_id&quot;, referencedColumnName = &quot;id&quot;) ) private List&lt;Role&gt; roles; @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; return this.authorities; &#125; @Override public String getUsername() &#123; return this.name; &#125; @Override public boolean isAccountNonExpired() &#123; return true; &#125; @Override public boolean isAccountNonLocked() &#123; return true; &#125; @Override public boolean isCredentialsNonExpired() &#123; return true; &#125; @Override public boolean isEnabled() &#123; return true; &#125;&#125; d. UserDetailsService username을 가지고 사용자 정보를 조회하고 session에 저장될 사용자 주체 정보인 UserDetails를 반환하는 Interface다. 각 시스템에서는 커스터마이징을 위한 구현체 클래스를 생성해야 한다. [참고] loadUserByUsername()에서 파라미터명을 username이 아니라 email로 변경한 이유는? 샘플 프로젝트 로그인 화면에서 email과 password로 로그인하기 때문에, username 파라미터에 email 값으로 호출된다. 로그인 화면 이동은 샘플 프로젝트 실행 후, 브라우저에서 “http://localhost:8080/login&quot; 주소로 이동한다. loadUserByUsername()에서 하는 일 username을 가지고 사용자 정보를 조회 사용자의 Role과 권한(Privilege)을 조회하여, SimpleGrantedAuthority 목록을 authorities에 세팅한다. Authentication 내부 principal 객체에 UserDetails 객체가 저장된다. Authentication 내부 authorities 객체에 사용자의 Role과 권한(Privilege) 정보가 저장된다. UserDetails에 authorities가 세팅되어 있어야, API별 role이나 권한 체크를 진행할 수 있다. 12345678910111213141516171819202122232425262728293031323334353637@Servicepublic class CustomUserDetailsService implements UserDetailsService &#123; private final UserService userService; public CustomUserDetailsService(UserService userService) &#123; this.userService = userService; &#125; @Override public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException &#123; User user = userService.getUser(email) .orElseThrow(() -&gt; new UsernameNotFoundException(&quot;User is not found. email=&quot; + email)); user.setAuthorities( Stream.concat( getRoles(user.getRoles()).stream(), getPrivileges(user.getRoles()).stream() ).collect(Collectors.toList()) ); return user; &#125; private List&lt;SimpleGrantedAuthority&gt; getRoles(List&lt;Role&gt; roles) &#123; return roles.stream() .map(Role::getName) .map(SimpleGrantedAuthority::new) .collect(Collectors.toList()); &#125; private List&lt;SimpleGrantedAuthority&gt; getPrivileges(List&lt;Role&gt; roles) &#123; return roles.stream() .flatMap(role -&gt; role.getPrivileges().stream()) .map(privilege -&gt; new SimpleGrantedAuthority(privilege.getName())) .collect(Collectors.toList()); &#125;&#125; e. GrantedAuthority GrantedAuthority는 ID, Password 기반 인증에서 UserDetailsService를 통해서 조회된다. high-level authority라고 부르는 이유는, 어플리케이션 전반에 걸친 권한이기 때문이다. 따라서 특정 도메인에 특화된 권한을 의미하지는 않는다. 즉, 시스템 레벨에서 필요한 권한이라고 생각하자. 만약 specific한 수 천개의 role을 가지고 있었다면, 빠르게 메모리를 사용했을 뿐만 아니라, 사용자 인증을 하는데 많은 시간이 걸렸을 것이다. 도메인 별로 구체적인 권한 체크가 필요한 경우에는, GrantedAuthority로 관리하지 않고, 각 API 별로 비지니스 권한을 체크한다. @PreAuthorize나 @Secured 어노테이션을 사용하여 API나 서비스별로 시스템 권한 체크는 할 수 있다. Authentication 클래스에 getAuthorities() 메소드를 통하여, 인증받은 사용자의 authorities를 조회할 수 있다.12// Authentication 클래스Collection&lt;? extends GrantedAuthority&gt; getAuthorities() f. SecurityContextHolder SecurityContext를 보관하는 저장소 SecurityContext에는 Authentication 인스턴스가 저장된다. Authentication에는 principal, credentials, authorities가 저장된다. g. CustomUserDetailsServiceTestspring test context를 띄워서 샘플 데이터를 대상으로 UserDetailsService가 잘 동작하는지 unit test를 수행한다.각 사용자별로 Role, 권한(Privilege)가 잘 조회되는지 결과값을 확인하는 Assertion 테스트로 작성하였다. Role 설명 임시 사용자, 일반 사용자, 어드민 사용자 Role로 구성된다. 피라미드로 생각하면, 아래서부터 위로 임시 사용자 &lt; 일반 사용자 &lt; 관리자 순이다. 일반 사용자는 임시 사용자 role도 가지기 때문에, 임시 사용자의 권한도 모두 포함한다. 관리자는 임시 사용자, 일반 사용자 role을 모두 가지기 때문에, 모든 권한을 가진다. 각 사용자별 테스트 검증 내용은 다음과 같다. user1 임시 사용자(ROLE_TEMPORARY_USER)로써, 의사소통 권한(COMMUNICATION_AUTHORITY)을 가지고 있는지 확인한다. user2 일반 사용자(ROLE_USER)로써 임시 사용자(ROLE_TEMPORARY_USER) Role도 가진다. 의사소통 권한(COMMUNICATION_AUTHORITY), 공정 관리(WORK_AUTHORITY), 일감 관리(TASK_AUTHORITY) 권한을 가진다. admin 관리자 (ROLE_ADMIN)로써, 일반 사용자, 임시 사용자 Role을 모두 가진다. 따라서 설정관리 권한(CONFIG_AUTHORITY)을 포함해서 모든 권한을 가진다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@ExtendWith(SpringExtension.class)@SpringBootTest(classes = StartSecurityApplication.class)class CustomUserDetailsServiceTest &#123; private static final String USER1_EMAIL = &quot;user1@gmail.com&quot;; private static final String USER2_EMAIL = &quot;user2@gmail.com&quot;; private static final String ADMIN_EMAIL = &quot;admin@gmail.com&quot;; @Autowired private CustomUserDetailsService userDetailsService; @Nested class loadUserByUsername &#123; @Test @DisplayName(&quot;throw UsernameNotFoundException when user not found with email&quot;) void errorCase() &#123; UsernameNotFoundException error = assertThrows(UsernameNotFoundException.class, () -&gt; userDetailsService.loadUserByUsername(&quot;not-found@gmail.com&quot;)); assertThat(error.getMessage()).isEqualTo(&quot;User is not found. email=not-found@gmail.com&quot;); &#125; @Test @DisplayName(&quot;given user1 is temporary user, when get role, then has temporary_user role and communication authority&quot;) void checkAuthorityAsTemporaryUser() &#123; UserDetails user1 = userDetailsService.loadUserByUsername(USER1_EMAIL); assertThat(user1.getAuthorities()) .extracting(GrantedAuthority::getAuthority) .contains(&quot;ROLE_TEMPORARY_USER&quot;, &quot;COMMUNICATION_AUTHORITY&quot;); &#125; @Test @DisplayName(&quot;given user2 is user, when get role, then has communication, user, temporary_user roles, and work, task authorities&quot;) void checkAuthorityAsUser() &#123; UserDetails user2 = userDetailsService.loadUserByUsername(USER2_EMAIL); assertThat(user2.getAuthorities()) .extracting(GrantedAuthority::getAuthority) .contains(&quot;ROLE_USER&quot;, &quot;ROLE_TEMPORARY_USER&quot;, &quot;COMMUNICATION_AUTHORITY&quot;, &quot;WORK_AUTHORITY&quot;, &quot;TASK_AUTHORITY&quot;); &#125; @Test @DisplayName(&quot;given admin is admin user, when get role, then has all of roles and authorities&quot;) void checkAuthorityAsAdminUser() &#123; UserDetails admin = userDetailsService.loadUserByUsername(ADMIN_EMAIL); assertThat(admin.getAuthorities()) .extracting(GrantedAuthority::getAuthority) .contains(&quot;ROLE_ADMIN&quot;, &quot;ROLE_USER&quot;, &quot;ROLE_TEMPORARY_USER&quot;, &quot;COMMUNICATION_AUTHORITY&quot;, &quot;WORK_AUTHORITY&quot;, &quot;TASK_AUTHORITY&quot;, &quot;CONFIG_AUTHORITY&quot;); &#125; &#125;&#125; API 권한 테스트샘플 프로젝트을 실행하여 로그인 후, 관리자 권한 사용자(&#x61;&#x64;&#109;&#x69;&#110;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;)로 로그인했을때만, 관리자 권한 API가 동작하는 것을 확인할 수 있다.테스트는 Postman을 사용해서 사용자 계정으로 로그인 후, 관리자 권한 API를 호출한다. 12345678910111213141516171819202122232425262728//UserController.java : 사용자 리소스 관리 Controller@RequestMapping(value = &quot;/v1/user&quot;)@RestControllerpublic class UserController &#123; private final UserService userService; public UserController(UserService userService) &#123; this.userService = userService; &#125; @GetMapping(value = &quot;/&#123;id&#125;&quot;) @PreAuthorize(&quot;hasRole(&#x27;ADMIN&#x27;)&quot;) public User getUser(@PathVariable long id) &#123; return userService.getUser(id); &#125; @PostMapping @PreAuthorize(&quot;hasRole(&#x27;ADMIN&#x27;)&quot;) @ResponseStatus(value = HttpStatus.CREATED) public User createUser(@RequestBody User user) &#123; if (!userService.getUser(user.getEmail()).isPresent()) &#123; throw new IllegalArgumentException(&quot;not found with email=&quot; + user.getEmail()); &#125; return userService.createUser(user); &#125;&#125; API 권한체크 설명 API에서 @PreAuthorize 어노테이션을 사용해서 Role 체크를 수행하고 있다. @PreAuthorize 어노테이션 내부에서 “hasRole” security expression을 사용하여 관리자(ROLE_ADMIN) 권한을 체크하고 있다. hasRole 내부에서 defaultRolePrefix 가 “ROLE_”을 붙여서 검사하기 때문에, hasRole 문법의 인자에는 순수하게 Role명만 입력하면 된다. 관리자 권한 API 사용자 조회 API : GET, &#x2F;v1&#x2F;user&#x2F;{id} 사용자 등록 API : POST, &#x2F;v1&#x2F;user 실패 사용자 계정 임시 사용자 권한 : &#x75;&#115;&#101;&#114;&#x31;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109; &#x2F; 1111 일반 사용자 권한 : &#117;&#115;&#101;&#x72;&#50;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#111;&#109; &#x2F; 2222 성공 사용자 계정 관리자 권한 : &#97;&#100;&#109;&#x69;&#110;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109; &#x2F; 3333 마무리이번 시간에 인증된 사용자 정보를 가리키는 UserDetails 인터페이스와 사용자 정보를 조회하는 UserDetailsService를 구현해 보았다.그리고 인증된 사용자 정보가 SecurityContext 내부에 Authentication 객체에 저장되는 것을 확인할 수 있었다. 또한 사용자 인증 후, Authentication에 세팅된 authorities를 기반으로, @PreAuthorize 어노테이션에 선언된 API 권한 체크까지 정상적으로 동작하는 것을 확인할 수 있었다. 마지막으로 이번 블로그 포스트를 통해서 아래 내용은 꼭 이해하고 갔으면 한다. Spring security 아키텍쳐에서 UserDetails, UserDetailsService에 대한 역할 시스템에서 사용하는 사용자의 Role과 권한(Previlege) 설계 방법 UserDetails에 Role과 권한(Previlege)을 GrantedAuthority로 세팅하는 방법 참고 Rhyno Github 실습 Repository Spring Security - Roles and Privileges Spring Security - 1. Authentication, SecurityContextHolder","categories":[{"name":"Spring security","slug":"Spring-security","permalink":"http://gregor77.github.io/categories/Spring-security/"}],"tags":[{"name":"Spring Security","slug":"Spring-Security","permalink":"http://gregor77.github.io/tags/Spring-Security/"},{"name":"Authentication","slug":"Authentication","permalink":"http://gregor77.github.io/tags/Authentication/"},{"name":"UserDetailsService","slug":"UserDetailsService","permalink":"http://gregor77.github.io/tags/UserDetailsService/"},{"name":"Role","slug":"Role","permalink":"http://gregor77.github.io/tags/Role/"},{"name":"GrantedAuthority","slug":"GrantedAuthority","permalink":"http://gregor77.github.io/tags/GrantedAuthority/"},{"name":"Privilege","slug":"Privilege","permalink":"http://gregor77.github.io/tags/Privilege/"}]},{"title":"Spring Security - 1. Authentication, SecurityContextHolder","slug":"spring-security-01","date":"2021-04-19T14:58:10.000Z","updated":"2022-12-26T06:02:24.385Z","comments":true,"path":"2021/04/19/spring-security-01/","link":"","permalink":"http://gregor77.github.io/2021/04/19/spring-security-01/","excerpt":"","text":"Authentication과 SecurityContextHolderSpring Security document를 보면서 SecurityContextHolder에 대해서 알아본다.Unit Test 기반으로 document에 설명되어 있는 내용을 직접 확인해보자.Spring Security 인증 모델에서 핵심은 SecurityContextHolder이다. AuthenticationSession에 저장되는 정보가 Authentication이라 생각하면 된다. Authentication은 역할에 따라서 principal, credentials, authorities, details로 구성된다.Authentication은 SecurityContextHolder 내부에 보관되는 SecurityContext에 저장된다. Principal 식별된 사용자 정보를 보관한다. UserDetails의 인스턴스이다. 시스템에 따라 UserDetails 클래스를 상속하여, 커스텀한 형태로 유지할 수 있다. Credentials 주체 (사용자)가 올바르다는 것을 증명하는 자격 증명이다. 보통 비밀번호를 의미하며, AuthenticationManager와 관련된 항목일 수 있다. Authorities AuthenticationManager가 설정한 권한을 의미 Authentication 상태에 영향을 주지 않거나 수정할 수 없는 인스턴스를 사용해야 한다. SecurityContextHolder 인증된 사용자의 구체적인 정보를 보관한다. Spring security는 SecurityContextHolder가 어떻게 만들어지는지에 대해서는 신경쓰지 않는다. 만약 값을 포함하고 있다면, 현재 인증된 사용자 정보로 사용된다. 사용자가 인증되었음을 나타내는 가장 간단한 방법은 SecurityContextHolder를 직접 설정하는 것이다. Test 1. SecurityContextHolder 세팅 및 조회1234567891011121314151617181920212223242526272829@BeforeEachvoid setUp() &#123; // 멀티 쓰레드에서 ContextHolder에 인증된 사용자 정보 세팅시, // race condition 상태를 피하기 위해서 새로운 SecurityContext를 생성한다. SecurityContextHolder.setStrategyName(SecurityContextHolder.MODE_THREADLOCAL); setMockAuthentication(ANY_USER, ANY_PASSWORD, USER_ROLE);&#125;@Test@DisplayName(&quot;SecurityContextHolder에 현재 인증된 사용자 정보를 세팅한다.&quot;)void securityContextHolder() &#123; Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); assertThat(authentication.isAuthenticated()).isTrue(); assertThat(authentication.getName()).isEqualTo(ANY_USER); assertThat(authentication.getCredentials()).isEqualTo(ANY_PASSWORD); assertThat(authentication.getAuthorities()) .extracting(GrantedAuthority::getAuthority) .contains(USER_ROLE);&#125;private void setMockAuthentication(String principal, String credential, String role) &#123; SecurityContext context = SecurityContextHolder.createEmptyContext(); Authentication mockAuthentication = new TestingAuthenticationToken(principal, credential, role); context.setAuthentication(mockAuthentication); SecurityContextHolder.setContext(context);&#125; Test 2. Multi Thread에서 SecurityContextHolder 조회기본적으로 SecurityContextHolder는 ThreadLocal을 사용하여 인증된 사용자의 세부 정보를 저장한다.SecurityContextHolder는 메소드에 인수로 명시적으로 전달되지 않더라도, 동일한 쓰레드의 메소드에서 사용할 수 있다.현재 principal의 요청이 처리된 후, 쓰레드를 지우도록 주의를 기울일 경우, ThreadLocal 기반의 방식은 매우 안전하다.Spring Security의 FilterChainProxy는 SecurityContextHolder가 항상 지우는 것을 보장한다. 일부 어플리케이션은 쓰레드를 사용하는 특정 방식으로 인해, ThreadLocal을 사용하는데 완전히 적합하지 않다. 예를들어 Swing 클라이언트는 JVM에 모든 쓰레드에서 같은 security context를 사용하기 원한다. SecurityContextHolder는 시작할 때 컨텍스트 저장 방법을 지정하는 전략으로 설정할 수 있다. Standalone한 어플리케이션의 경우, MODE_GLOBAL 전략을 사용하여 SecurityContextHolder를 사용할 수 있다. Multi Thread에서 exception handlingMulti thread에서 발생한 exception은 thread 바깥에서 try..catch 블럭을 사용해서 exception 접근이 안된다.UncaughtExceptionHandler를 구현하여 thread에서 발생한 exception을 처리할 수 있다. 두 가지 방법으로 thread에서 발생한 exception을 처리할 수 있다. 모든 Thread에서 발생하는 default Exception handler 지정 Thread 별로 exception handler 지정 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class SampleThread extends Thread &#123; @Override public void run() &#123; super.run(); Optional.ofNullable(SecurityContextHolder.getContext()) .map(SecurityContext::getAuthentication) .orElseThrow(() -&gt; new RuntimeException(&quot;Multi thread...authentication is null&quot;)); &#125;&#125;class SampleExceptionHandler implements Thread.UncaughtExceptionHandler &#123; private String handlerName; private Runnable errorHandler; private CountDownLatch latch; public SampleExceptionHandler(String handlerName, Runnable errorHandler) &#123; this.handlerName = handlerName; this.errorHandler = errorHandler; &#125; public SampleExceptionHandler(String handlerName, Runnable errorHandler, CountDownLatch latch) &#123; this.handlerName = handlerName; this.errorHandler = errorHandler; this.latch = latch; &#125; @Override public void uncaughtException(Thread t, Throwable e) &#123; System.out.println(this.handlerName + &quot; : &quot; + e.getMessage()); this.errorHandler.run(); latch.countDown(); &#125;&#125;@Test@DisplayName(&quot;try...catch 블록으로 thread 외부에서 exception을 핸들링 할 수 없다.&quot;)void errorCase() &#123; Stream.of(new SampleThread(), new SampleThread()) .forEach(thread -&gt; &#123; try &#123; thread.start(); assertThat(true).isTrue(); &#125; catch (Exception e) &#123; Assertions.fail(&quot;try...catch 블록으로 thread exception 핸들링 할 수 없다.&quot;); &#125; &#125;);&#125; Multi Thread에서 검증을 위한 Unit Test 작성 계획Thread가 종료되고 나서, 각각의 exception handler가 호출되었는지 확인한다. Thread가 종료될때까지 기다리기 위해서 CountDownLatch를 thread 갯수만큼 선언했다. exception Handler에서 에러를 처리하고 나서, latch.countDown() 호출하여, 갯수를 줄여준다. latch.await()를 사용하여 latch count가 0이 될때까지 기다린다. 그 이후에 verify를 통해서, exception handler가 호출되었는지 확인한다. 1. default exception handler 지정모든 Thread에 적용되는 default exception handler를 지정할 수 있다. Thread를 2개를 사용하기 때문에, verify 테스트시에 defaultExceptionHandler가 2번 호출되었는지 확인한다.123456789101112@Test@DisplayName(&quot;Multi Thread 에러 핸들링 - default thread exception handler 지정&quot;)void withDefaultExceptionHandler() throws InterruptedException &#123; CountDownLatch latch = new CountDownLatch(2); Runnable defaultErrorHandler = mock(Runnable.class); Thread.setDefaultUncaughtExceptionHandler(new SampleExceptionHandler(&quot;defaultHandler&quot;, defaultErrorHandler, latch)); Stream.of(new SampleThread(), new SampleThread()).forEach(SampleThread::start); latch.await(); then(defaultErrorHandler).should(times(2)).run();&#125; 2. Thread 별로 exception handler 지정Thread 별로 각각의 exception handler 지정할 수 있다. 각 Thread별로 exceptionHandler를 지정했다. Thread가 종료 후에 각각의 exceptionHandler가 한번씩 호출되었는지 확인한다.12345678910111213141516171819@Test@DisplayName(&quot;Multi Thread 에러 핸들링 - thread마다 exception handler 지정&quot;)void withExceptionHandlerEachThread() throws InterruptedException &#123; CountDownLatch latch = new CountDownLatch(2); SampleThread firstThread = new SampleThread(); Runnable firstExceptionHandler = mock(Runnable.class); firstThread.setUncaughtExceptionHandler(new SampleExceptionHandler(&quot;firstHandler&quot;, firstExceptionHandler, latch)); SampleThread secondThread = new SampleThread(); Runnable secondExceptionHandler = mock(Runnable.class); secondThread.setUncaughtExceptionHandler(new SampleExceptionHandler(&quot;secondHandler&quot;, secondExceptionHandler, latch)); Stream.of(firstThread, secondThread).forEach(SampleThread::start); latch.await(); then(firstExceptionHandler).should(times(1)).run(); then(secondExceptionHandler).should(times(1)).run();&#125; Multi thread 환경에서 SecurityContextHolder의 전략 수정ThreadLocal기반의 ContextHolder를 사용시, Multi thread 환경에서는 기존 쓰레드에 담긴 내용을 동기화해주는 작업을 별도로진행해야 한다. SecurityContextHolder의 경우는 세가지의 전략을 지원하고, Multi thread 환경에서 적절한 전략을 선택하면 된다. Strategy 종류 MODE_THREADLOCAL : 기본 설정 MODE_INHERITABLETHREADLOCAL : 멀티 쓰레드에서 새로운 안전한 쓰레드를 생성하는 경우에 기존 쓰레드와 동일하게 사용하고 싶은 경우 MODE_GLOBAL : standalone application에서 사용 Unit Test 설명 SecurityContextHolder의 전략을 MODE_INHERITABLETHREADLOCAL로 지정 mock 인증 정보 생성 Multi thread 수행시, SecurityContextHolder에 기존 쓰레드에 지정된 authentication 정보가 새로운 thread에도 지속디는 것을 확인12345678910111213@Test@DisplayName(&quot;SecurityContextHolder에서 threadLocal mode변경을 통해서, multi thread에서 동기화 가능&quot;)void withGlobalMode() &#123; SecurityContextHolder.setStrategyName(SecurityContextHolder.MODE_INHERITABLETHREADLOCAL); setMockAuthentication(ANY_USER, ANY_PASSWORD, USER_ROLE); Runnable defaultErrorHandler = mock(Runnable.class); Thread.setDefaultUncaughtExceptionHandler(new SampleExceptionHandler(&quot;defaultHandler&quot;, defaultErrorHandler)); Stream.of(new SampleThread(), new SampleThread()).forEach(SampleThread::start); then(defaultErrorHandler).should(never()).run();&#125; 마무리SecurityContextHolder는 인증된 사용자 정보 저장소로써 역할을 수행한다. 기본적으로 ThreadLocal 기반으로 사용하며, Multi thread 환경에서 기존 인증정보를 sync해서 사용하기 위해서는 strategy 수정이 필요하다. 메소드 호출시 인증정보를 파라미터로 전달받지 않더라도, SecurityContextHolder에 접근하면 인증된 사용자 정보 확인이 가능하다. 물론 layer(Controller-Service-Repository)를 넘나들면서 SecurityContextHolder에 접근은 가능하지만, 인증정보를 session 이라고 생각한다면,Presentation Layer의 역할인 Controller에만 SecurityContextHolder에 접근하고, 나머지 layer에서는 메소드 파라미터로 전달받는 것이 바람직해보인다. Java 8에서 멀티 쓰레드에서 exception을 다루기 위한 방법에 대해서도 알아보았다. default uncaughtExceptionHandler를 사용하여 모든 쓰레드에 공통적으로 적용 각 Thread별로 exception handler를 지정 본문에서 테스트해보지는 않았지만 두 가지 방법을 혼용해서도 사용가능하다. 마지막으로 Unit Test에서 Multi thread 상태가 종료될 때까지 assertion을 기다리기 위해서,java.util.concurrent.CountDownLatch를 사용하는 방법도 알아보았다. CountDownLatch를 사용하여 멀티 쓰레드 환경에서 테스트를 작성할 수 있었다. 참고 Rhyno Git repository - SecurityContextHolder Spring security document Java8 multi thread exception handling","categories":[{"name":"Spring security","slug":"Spring-security","permalink":"http://gregor77.github.io/categories/Spring-security/"}],"tags":[{"name":"Authentication","slug":"Authentication","permalink":"http://gregor77.github.io/tags/Authentication/"},{"name":"Spring security","slug":"Spring-security","permalink":"http://gregor77.github.io/tags/Spring-security/"},{"name":"SecurityContextHolder","slug":"SecurityContextHolder","permalink":"http://gregor77.github.io/tags/SecurityContextHolder/"},{"name":"Multi Thread","slug":"Multi-Thread","permalink":"http://gregor77.github.io/tags/Multi-Thread/"},{"name":"CountDownLatch","slug":"CountDownLatch","permalink":"http://gregor77.github.io/tags/CountDownLatch/"},{"name":"Unit Test","slug":"Unit-Test","permalink":"http://gregor77.github.io/tags/Unit-Test/"}]},{"title":"서평 - 실전대비 C 알고리즘 인터뷰","slug":"book-review-실전대비C알고리즘인터뷰","date":"2021-01-06T12:42:28.000Z","updated":"2022-12-26T06:02:24.385Z","comments":true,"path":"2021/01/06/book-review-실전대비C알고리즘인터뷰/","link":"","permalink":"http://gregor77.github.io/2021/01/06/book-review-%EC%8B%A4%EC%A0%84%EB%8C%80%EB%B9%84C%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%B8%ED%84%B0%EB%B7%B0/","excerpt":"","text":"알고리즘은 공부해야 한다?!!몇 년 전부터 알고리즘 기반의 코딩 테스트의 중요성이 높아졌다. 특히 회사에서도 알고리즘 테스트를 진행하고 있다. 변명일 수도 있지만 이전에만 하더라도, 나에게 알고리즘은 알고 있으면 좋지만 시간을 들이며 공부할 필요성을 느끼지 못했다.그 시간에 실제 일을 진행하는데 필요한 기술과 지식을 공부하는 게 더 낫다고 생각했다. 그러고 시간이 흘러 이직을 위해 면접을 보게 되었다. 좋은 기회였음에도 불구하고, 프로젝트도 바쁘고, 한 번에 통과하기 어렵겠지라는 안일한 생각에 충분히 준비를 하지 못했다.코딩 테스트는 몇 년 동안 매일 가장 많은 시간을 보내는 일이 개발이다 보니 막연히 크게 걱정하지 않았다. 대략 세 시간에 걸쳐 면접을 진행했다. 1시간마다 다른 면접관들과 인터뷰를 진행했고, 마지막은 항상 코딩 테스트를 진행했다. 문제는 비교적 간단한 알고리즘이었다. 하지만 충분히 연습이 되어있지 않는 상태에서, 모르는 알고리즘을 구현하려고 하니 생각대로 잘되지 않았고, 특히 면접이라는 특수한 상황 때문에 막히는 부분들이 생길수록 말리기 시작했다.면접관들과 질의응답은 부족한 상태로 라이브 코딩 테스트를 마무리하게 되었다. 그 면접 이후로 나는 알고리즘과 코딩 인터뷰는 시간과 노력을 들여서 공부해야 한다 생각하게 되었다. 현재 대부분의 개발자 채용 과정에서 코딩 테스트는 이루어진다. 물론 채용 인터뷰 과정에서 온전히 내가 어떤 경험과 능력을 가지고 있는지 드러내기는 어렵다고 생각한다.하지만 현실적으로 내가 새로운 기회를 얻기 위해서는 알고리즘을 알아야 하고, 코딩 인터뷰를 잘 진행할 수 있는 준비가 되어있어야 한다. 알고리즘을 공부하면서 기존에 개발된 시스템에 성능 문제가 발생하면, 어떻게 시간 복잡도를 줄일 수 있을지 고민하게 되고 생각의 범위도 넓혀서 고민할 수 있게 되는 점도 알고리즘 공부를 통해서 얻을 수 있는 이점이다. “실전 대비 C 알고리즘 인터뷰“ 책을 읽게 되다. 면접 실패를 경험하고, 프로젝트도 한가해지면서 알고리즘 공부를 하고 있었다. 길벗에서 진행하는 개발자 리뷰어 기회를 통해서 “실전 대비 C 알고리즘 인터뷰”를 신청하여 읽게 되었다. 책의 목차를 읽고 나서, 나처럼 알고리즘 공부를 시작하는 사람들이나 코딩 인터뷰 경험이 부족한 사람들에게 도움이 되지 않을까 하는 기대가 생겼기 때문이다.이 책을 읽고 나서 이 책을 읽어볼까 고민하고 있을 사람들에게 도움이 되었으면 하는 바람에 내용을 정리해보았다. 어떤 사람들이 읽으면 도움이 될까? 자료구조나 기본적인 알고리즘을 공부하려는 사람 알고리즘 공부를 시작하려는 입문자 문제 접근법을 알아도 코드로 구현이 어려운 사람 “자료구조나 기본적인 알고리즘을 공부하려는 사람”책에 절반에 걸쳐서 자료 구조, 기본적인 알고리즘을 다룬다. 이론 설명을 실제로 돌아가는 코드를 통해서 보여주기 때문에 독자가 실제로 예제를 보고 구현할 수 있는 점이 장점이다. 이론 부분만 있거나 의사 코드(pseudocode)만 있는 경우에 실제로 구현하려하면 잘 안되는 경우도 있어 구글에서 검색하는 경우도 많다. 하지만 이 책은 책만 보고도 알고리즘 구현까지 완성할 수 있는 점이 장점이다. “알고리즘 공부를 시작하려는 입문자”시간 복잡도에 대한 개념이 부족하거나, 시간 복잡도를 개선하는 방법에 미숙한 경우 이 책은 도움이 된다. 실제로 예시를 해결하는 방법을 여러 단계에 걸쳐서 설명을 진행한다. 브루트 포스부터 시작해서 시간 복잡도를 개선할 수 있는 방법으로 설명을 진행한다. 시간 복잡도 개선하는 방법에 익숙하지 않은 사람의 경우 이 책의 접근 방식은 도움이 될 것이다. 또한 자료구조나 기본적인 알고리즘을 중점으로 다양한 케이스별 예시가 있고, 구현 코드가 반복해서 이어진다. 알고리즘 공부를 시작하려는 입문자가 알고리즘 구현 연습을 할때 참조하기 좋은 책이라 생각한다. “문제 접근법을 알아도 코드로 구현이 어려운 사람”만약 책을 읽고자 하는 사람이 C 언어를 모르고 다른 프로그래밍 언어만 안다고 하더라도 책을 읽기에 크게 어려움은 없다. 책을 보다 보면 읽는다는 느낌보다는 알고리즘 유형별로 구현 코드를 참고할 수 있는 쿡북에 가깝다. 케이스별로 실제로 돌아가는 코드가 있기 때문에 문제 접근 방식은 알더라도 코드로 구현하기 어려운 사람이 보기에 좋다. 이 책에 부족한 부분 대부분 코드 위주의 설명으로 진행되기 때문에 알고리즘 유형별 이론적인 설명이나 문제별 접근법에 대한 충분한 설명은 부족하다. 책을 읽기 전에 기대했었던 코딩 인터뷰를 잘 진행하는 방법에 대한 설명은 너무 짧다. 마치며요즘에는 알고리즘을 공부할 수 있는 다양한 방법들이 존재한다. “백준”같은 온라인 문제풀이 사이트, 온라인 강의, 알고리즘을 다루는 다양한 서적들도 존재한다. 다양한 컨텐츠들 사이에서 막상 알고리즘 공부를 시작하려면 현재 내 수준에 맞는 방법을 찾기 어렵다. 온라인 문제풀이 사이트에서 문제를 풀어보려고 하면 어떤 알고리즘을 써야할지 생각이 안 떠올를 수도 있고, 알고리즘을 막상 사용하려고 하면 어떻게 구현해야 할지 모르겠는 경우도 있다. 알고리즘 입문자나 익숙해질 때까지 자료구조, 알고리즘 구현하는 연습을 할 때 이 책은 큰 도움이 된다. 개인적으로는 문제 사이트에서 문제를 풀 때 어떤 자료 구조나 알고리즘을 구현해야 하는데 구현 방법이 떠오르지 않을 때 참고하기에 좋았다. 마지막으로 알고리즘을 공부하거나 이 책을 읽어보려는 사람들에게 리뷰가 도움이 되었으면 한다.","categories":[{"name":"Review","slug":"Review","permalink":"http://gregor77.github.io/categories/Review/"}],"tags":[{"name":"SW Engineering","slug":"SW-Engineering","permalink":"http://gregor77.github.io/tags/SW-Engineering/"}]},{"title":"서평 - 심플 소프트웨어","slug":"book-review-simple-sw","date":"2019-11-19T11:00:28.000Z","updated":"2022-12-26T06:02:24.385Z","comments":true,"path":"2019/11/19/book-review-simple-sw/","link":"","permalink":"http://gregor77.github.io/2019/11/19/book-review-simple-sw/","excerpt":"","text":"길벗에 개발자 리뷰 신청 글을 보다가, 100년 뒤에도 유용할 소프트웨어 설계 원칙 &amp; 프로그래머의 바른 길! 문구에 이끌려 “심플 소프트웨어”라는 책 리뷰를 하게 되었다.이전에 “소프트웨어 장인”이라는 책을 인상깊게 읽었는데 그와 비슷한 표지에, 강렬한 문구에 이 책을 읽고나면 깨달음을 얻을 수 있을거란 기대감이 생겼다. 책을 읽었으면 하는 사람들소프트웨어 엔지니어로 일을 하거나, 현재 일하는 방식을 변화하고 싶은 사람들이 읽었으면 합니다. 많은 시행착오로 알게 된 지식들이 깔끔하고 이해하기 쉽게 정리되어 있습니다. 3년 넘게 소프트웨어 엔지니어링 팀에 있으면서 많은 개발팀을 만나 생산성을 높이거나, 현재 개발팀의 애로사항을 해결하는 일들을 해왔다. 그 와중에 현재 문제를 해결하기 위해 주로 애자일, XP의 방법을 활용했다. 처음에는 방법을 몰라서 프랙티스에 치중을 했다. 하지만 프랙티스만으로는 팀을 변화시키기가 너무 힘들었다. 간혹 강성의 개발자들을 만나면 왜 이런 프랙티스를 해야하는지를 두고 매번 설득과 논쟁(?)의 시간을 겪었고,그럴때마다 정신적으로나 감정적으로 스트레스가 컸다. 물론 시간이 지나서 돌이켜보니, 내가 너무 어설펐고 애자일에 대한 성숙도가 낮은 상태가 문제의 원인이었다. 그들은 나아지고 있다는 믿음이 없는 상태에서 변화만 요구하는 것처럼 느껴졌을 것이다. 그런 상황이 길어지면서 서로 답답하고 신뢰하지 못하는 상황에서 계속 부딪히다 보니 누군가는 포기하고 서로에게 답답한 시간이었을 것이다. 이런 시도 반복하다보니, 초반에 개발팀 신뢰를 얻는 것이 중요하다는 것을 알게 되었다. 신뢰를 많이 쌓을수록 팀의 변화는 더 크게 일어났고, 신뢰를 쌓지 못하면 서로 힘들어지고, 이전과 바뀐다는 느낌은 없이 일만 같이하는 사이로 끝나는 경우도 있었다. 신뢰를 쌓는 일은 개발자들이 현재 일하는데 불편한 점을 찾아서 그것부터 해결해나가다보니 자연스레 얻을 수 있었다. 현재 상황에서 더 나은 상황으로 변할 수 있을거라는 기대감이 생기고 그게 확신으로 변해나가는 경험이 반복될 수록, 이전과 다른 일하는 방식에도 긍정적으로 참여했다. 변화할 수 있다는 확신이 개발자, 팀의 변화에 동기부여가 됐다. 꼭 읽어야하는 이유이전에 이 책을 읽었더라면, 소프트웨어 엔지니어로써 더 많은 개발자에게 도움이 되었을텐데라는 생각이 가장 먼저 들었다. 시행착오를 통해 알게된 내용들이 너무 잘 정리되어있었다. 개발자들과 많은 이야기를 하다보면 개인 경험치에 따라 공유하는 내용의 깊이가 달라진다. 내용의 깊이에 따라 사람들을 얼마나 몰입시키는지가 결정된다.이 책을 읽으면서 느낀점은 독자가 현재 상황을 개선하기 위해서 많은 경험을 했고, 얼마나 많은 고민을 했었는지가 느껴졌다. 책에 나와있는 상황들에 몰입이 되었고, 내가 현재 일하는 환경에 연결되어 내 상황은 어떤지, 나는 어떤 선택을 할 것인지 돌이켜보게 된다. 소프트웨어 엔지니어라면 많은 경험을 통해 알 수 있는 점들이 잘 정리되어 있다. 팀의 변화를 시도하고 싶은 사람이 어떤 방법을 통해 해결해야 할지 모르는 경우, 방법을 알려주는 지침서가 될거라 생각한다. 심플 디자인의 중요성을 다양한 사례를 통해서 공감할 수 있다. 경험이 적은 주니어 개발자나 혹은 혼자 일하고 있는 개발자들에게 조언이 된다. 개발 코드가 없어서 몰입해서 가볍게 읽을 수 있다. 아쉬운 점책의 표지를 보면 “코드의 단순성, 가독성, 안전성, 유지보수를 위한 심플 소프트웨어”라고 되어있다. 그것만 보고 개발코드를 예를 들면서 복잡도를 낮추는 설계 방법이 있을거라 기대하는 사람들은 실망할 수 있다.이 책은 코드의 단순성, 가독성, 안정성, 유지보수를 위한 심플 소프트웨어가 왜 중요한지 배경 설명을 위한 책이다. 상황에 따른 경험담을 바탕으로 왜 심플 소프트웨어를 만들어야하는지, 어떤 방법으로 목적을 달성할 수 있는지 소프트웨어 공학 관련된 내용이기 때문에 클린 코드를 위한 코딩 가이드를 기대하지 마라. 마무리개발하는 사람이라면 꼭 한번은 읽어봤으면 하는 책이다. 개발자로써 경험이 달라져도 그때마다 새로운 인사이트를 얻을 수 있는 책이라 생각한다.내 역할이 개발자, 소프트웨어 엔지니어, 팀리더 등으로 변하더라도 그때마다 얻는 가치들이 분명이 존재할거라 생각합니다. 알게된 내용을 현재 내 상황에 적용해 본다면 더 즐거울거라 생각합니다. 내가 개발업무를 하던, 운영업무를 하던 소프트웨어 개발을 하고, 유지보수를 하고 있는 사람이라면 현재의 상황을 개선하는데 도움되는 실용적인 팁을 얻을 수 있을 것입니다. 그러기 위해서는 단순히 내용만 읽고 넘기는 것이 아니라, 책의 상황에 몰입하고 고민해야 더 큰 깨달음을 얻을거라 생각합니다.","categories":[{"name":"Review","slug":"Review","permalink":"http://gregor77.github.io/categories/Review/"}],"tags":[{"name":"SW Engineering","slug":"SW-Engineering","permalink":"http://gregor77.github.io/tags/SW-Engineering/"}]},{"title":"서평 - 혼자 공부하는 C언어","slug":"book-review-study-c-alone","date":"2019-09-14T13:14:28.000Z","updated":"2022-12-26T06:02:24.385Z","comments":true,"path":"2019/09/14/book-review-study-c-alone/","link":"","permalink":"http://gregor77.github.io/2019/09/14/book-review-study-c-alone/","excerpt":"","text":"책을 읽게된 배경한빛미디어에서 진행하는 “나는 리뷰어다” 8월 미션을 통해서 이 책을 읽고 리뷰를 남기게 되었다. 현재 학교를 졸업하고 개발자로써 9년차에 접어들었다. 주로 자바와 자바스크립트를 사용하여 개발을 진행해왔고, 학교에서만 C언어, 자료구조와 알고리즘, 운영체제 과목을 통해서만 C를 접했지 회사에서 일하면서 C를 접한적은 한번도 없는 것 같다. 학교다닐때도 처음 접한 C는 너무 어려운 프로그래밍 언어였다. 이중 포인터의 능선을 넘기지 못하고 쥐쥐친 언어로 기억하고 있다. 그 이후에 C로 실습하는 과목들 또한 어려웠고 그것때문인지 모르겠지만 일단 C언어라고 하면 어려운 언어라는 편견이 있다. 이번에 “나는 리뷰어다” 이벤트를 통해서 이 책을 신청하게 된 이유는, 지금 C언어를 공부해도 학생때 처럼 똑같이 어려울까 하는 호기심과 최근에 알고리즘 공부를 하려고 하는데 C언어로 공부하면 재미있을거 같아서였다. 이 책을 읽지 않은 상태에서 먼저 목차를 봤을때 초급편, 고급편으로 나눈 구성이 마음에 들었다. 그리고 배타리더의 만족스러운 소감들이 책 제목처럼 혼자 공부해서 C언어라는 큰 벽을 오를 수 있지 않을까라는 기대가 생겼다. 좋았던 점“C언어를 알고 싶은 누구나 읽기에 부담스럽지 않다.”이 책은 초심자나 프로그래밍 경험이 없는 사람들이 읽기에 전혀 부담스럽지 않을 것 같다. 전공서적임에도 불구하고 책의 내용이 딱딱하거나 재미없다고 느껴지지 않는다. 익숙하지 않은 용어에 대해서 설명을 해주고, 이미지를 많이 활용해서 쉽게 이해할 수 있게 도와주기 때문이다. 그리고 챕터가 시작할때 개념적인 부분을 실생활에 찾을 수 있는 예를 들어 설명하는 부분이 독자로 하여금 왜 이런 부분이 필요한 것인지 공감할 수 있게 한다. 단순히 문법으로 바로 시작했으면 딱딱하거나 어렵게 느껴질 수 있었을텐데 저자가 독자에 대한 배려가 많다는 느낌이 들었다. “어려운 내용도 이해하기 쉽게 설명해 준다.”학부생때 포인터와 이중 포인터에서 머리가 안돌아가서 포기했었다. 이번 리뷰의 개인적인 목표는 포인터 관련 부분을 이해할 수 있을 것인가 하는 거였다. 일단 책에서는 포인터 내용이 고급편에 포함되어 있어 상대적으로 위안이 되었다. 내가 너무 빠르게 C언어를 포기하지 않았구나라는 점에서 말이다. ㅎㅎ 책을 읽으면서 간결한 문체가 책 보는 내내 집중할 수 있어서 좋았다. 전공서적을 읽다보면 너무 어렵게 설명을 하거나 또는 문체가 길어서 무슨 말을 하는지 이해하지 못하는 경우가 있는데, 이 책에서는 그러는 경우가 단 한번도 없었다. 그리고 개념적인 부분을 그림을 통해서 부가 설명을 해주는데 그 덕분에 이해하기 쉬웠다. 이 책을 보면서 내가 대학생때 이 책이 있었다면 C언어를 포기하지 않았을텐데 생각이 들었다. 왜냐면 학부생때 봤던 책은 정말 내용이 딱딱했고, 개념적인 부분에 대한 설명이 충분치 않았다. 교수님이 분명 설명해줬지만 내가 이해하지 못한 상태서 계속 다음 진도를 나가니 결국엔 따라가지 못하고 포기했었다. 하지만 이렇게 잘 설명되어 있는 책이 있었다면 개인적으로 공부하면서 수업을 따라갈 수 있었을 것 같다는 생각이 들었다. 마무리새로운 프로그래밍 언어를 공부할 때 가장 좋은 방법은 많이 사용해보는 것이다. 새롭게 알게된 C언어 문법을 알고리즘 문제를 푸는데 활용해보자. 꼭 어려운 알고리즘 문제가 아니더라도, 간단한 알고리즘 문제를 C언어로 풀어보면서 문법에 익숙해질 수 있었다. 백준 알고리즘 사이트에는 다양한 알고리즘 문제가 많으니 관심있는 사람들은 참고해도 좋을 것 같다. 마지막으로 이 책은 C언어를 공부할때 필요한 내용은 다 다루고 있기 때문에, 초심자나 다시 공부해보려는 사람들에게 좋은 지침서가 될 것이라 생각한다. 그리고 자료구조나 알고리즘을 C언어로 공부해보면 자연스럽게 배운 내용을 활용할 수 있기 때문에 병행하는 것도 추천한다.","categories":[{"name":"Review","slug":"Review","permalink":"http://gregor77.github.io/categories/Review/"}],"tags":[{"name":"C 언어","slug":"C-언어","permalink":"http://gregor77.github.io/tags/C-%EC%96%B8%EC%96%B4/"}]},{"title":"Hexo Hueman Theme 블로그 - 파싱할 수 없는 구조화된 데이터","slug":"hexo-hueman-unparsed-structured-data","date":"2019-08-19T04:35:09.000Z","updated":"2022-12-26T06:02:24.385Z","comments":true,"path":"2019/08/19/hexo-hueman-unparsed-structured-data/","link":"","permalink":"http://gregor77.github.io/2019/08/19/hexo-hueman-unparsed-structured-data/","excerpt":"","text":"Hexo Hueman 테마를 사용하여 개발자 블로그를 운영중이다. 그런데 새로 작성한 글들이 구글에서 조회가 되지 않는 것이다.처음에는 크롤링을 하지 않아서 그런 것이겠지 했는데, 몇일이 지나도 계속 조회가 되지 않았다.이번 글은 Google Search Console을 통해서 구글에서 작성한 글이 검색되도록 한 과정과 용어들을 공유하겠다. Google Search Console처음 개발자 블로그를 만들고 구글에 블로그를 노출시키기 위해서, sitemap을 추가하기 위해 Google Search Console을 처음 접했다.그리고 얼마후 블로그에 게시한 글들이 구글에서 조회가 되는 것을 보고, 그 이후에는 Google Search Console에 따로 접속하지 않았다. 최초에 landscape 테마를 사용하다가, 너무 클래식한거 같아서 Hueman 테마로 변경했다. 그런데 Hueman 테마로 변경후부터 구글에서 새로운 글이 검색이 되지 않았다.Google Search Console에 접속해서 “실적” 메뉴를 보면 페이지 노출수를 확인할 수 있다. 예상대로 새로 작성된 post 자체가 보이지 않았다. Search Console에 등록된 블로그의 sitemap.xml은 잘 조회되고 있었기 때문에, 혹시 Googlebot이 크롤링을 제대로 못하는 것이 아닌가 의심이 갔다.Search Console에서 “URL 검사”라는 메뉴를 사용하면 입력된 URL 주소로 Google에서 생성한 색인의 현재 상태를 확인할 수 있었다. 원인은 Hueman Theme에서 새로 작성한 글들은 “파싱할 수 없는 구조화된 데이터” 에러를 발생하고 있었고 Googlebot이 크롤링을 실패하면서 검색이 안 되는 것이었다.에러 내용을 클릭하면, 오른쪽 탭에 “크롤링된 페이지” 상세 정보를 확인할 수 있고, 마치 개발자도구 처럼 어디 부분에서 에러가 발생했는지 확인할 수 있다.이미 크롤링되서 색인된 페이지가 아닌, URL 기반으로 실시간으로 테스트를 해서 현재 페이지의 상태를 확인하고, 색인생성 가능여부를 판단할 수 있다 . 해결방법 : 구조화된 데이터 테스팅 도구구조화된 데이터 테스트 도구를 사용하면, 입력된 URL에 조회되는 데이터의 구문을 수정하고 테스트 할 수 있다. 마치 개발자 도구처럼 데이터를 수정할 수 있고, 오른쪽에 현재 데이터 상태를 바로 확인할 수 있기 때문에 편하다.URL에 내 블로그에 등록된 글 주소를 입력해보았는데 역시나 구조화된 데이터로 파싱되지 못하는 에러가 있었다. [오류] 카테고리가 없는 오류 - Object parsing 실패 JSON-LD: 개체 선언에 “,” 또는 “}”가 누락되었습니다. JSON-LD 값을 확인하면, “description”의 값 다음에 “,”가 없어서 제대로된 Object로 인지를 못한다. description의 값 다음에 “,”을 추가하고 다시 테스트를 해보면, 해당 에러는 없어지고 JSON-LD에 publisher, mainEntityOfPage 속성을 추가하라는 경고와 오류가 발생한다. [오류] JSON-LD 속성 추가 - publisher, mainEntityOfPageHexo에 Hueman 테마를 보면 ld_json.ejs 파일이 있다. 파일을 보면, JSON을 사용하여 JSON을 RDF로 변환하는데 필요한 모델의 추가적인 매핑정보가 작성되어 있다.JSON-LD를 표현하는 방식은 Schema.org 사이트를 참고하면 의미와 사용법에 대해서 상세히 설명되어 있다.아래처럼 ld_json.ejs 파일을 변경하고, hexo로 다시 deploy 후 Google Search Console에서 실시간 URL 검사를 하면 정상적으로 나오는 것을 확인할 수 있다.hexo deploy를 한다고 해서 Googlebot이 바로 크롤링을 하지 않기 때문에, 실시간 테스트를 통해 테스트를 해야한다. description의 값 뒤에 “,” 추가 publisher 속성 추가 페이지의 출판자를 의미 mainEntityOfPage 속성 추가 설명중인 주요 항목인 페이지에 대한 설명을 의 1234567891011121314151617181920212223242526//ld_json.ejs 파일 변경&lt;script type=&quot;application/ld+json&quot;&gt; &#123; &quot;@context&quot;: &quot;https://schema.org&quot;, &quot;@type&quot;: &quot;BlogPosting&quot;, &quot;author&quot;: &#123; &quot;@type&quot;: &quot;Person&quot;, &quot;name&quot;: &quot;&lt;%= config.author %&gt;&quot; &#125;, &lt;% if (post.title) &#123; %&gt;&quot;headline&quot;: &quot;&lt;%= post.title %&gt;&quot;,&lt;% &#125; %&gt; &quot;image&quot;: &quot;&lt;%- url_for(config.url + thumbnail(post)) %&gt;&quot;, &lt;% if (post.tags) &#123; %&gt;&quot;keywords&quot;: &quot;&lt;%- post.tags.map(t =&gt; t.name).join(&#x27; &#x27;) %&gt;&quot;,&lt;% &#125; %&gt; &lt;% if (post.categories) &#123; %&gt;&quot;genre&quot;: &quot;&lt;%- post.categories.map(c =&gt; c.name).join(&#x27; &#x27;) %&gt;&quot;,&lt;% &#125; %&gt; &quot;datePublished&quot;: &quot;&lt;%- date(post.date, &#x27;YYYY-MM-DD&#x27;) %&gt;&quot;, &quot;dateCreated&quot;: &quot;&lt;%- date(post.date, &#x27;YYYY-MM-DD&#x27;) %&gt;&quot;, &lt;% if (post.updated) &#123; %&gt;&quot;dateModified&quot;: &quot;&lt;%- date(post.updated, &#x27;YYYY-MM-DD&#x27;) %&gt;&quot;,&lt;% &#125; %&gt; &quot;url&quot;: &quot;&lt;%- url_for(config.url + &#x27;/&#x27; + post.path) %&gt;&quot;, &quot;description&quot;: &quot;&lt;%- excerpt(post) %&gt;&quot;, &quot;wordCount&quot;: &quot;&lt;%- post.content.split(&#x27; &#x27;).length %&gt;&quot;, &quot;publisher&quot;: &quot;&lt;%= config.author %&gt;&quot;, &quot;mainEntityOfPage&quot;: &#123; &quot;@type&quot;: &quot;WebPage&quot;, &quot;@id&quot;: &quot;&lt;%- url_for(config.url + &#x27;/&#x27; + post.path) %&gt;&quot; &#125; &#125;&lt;/script&gt; SEO, Sementic Web, JSON-LD구글에서는 크롤링을 할때 수집하려는 리소스가 구조화된 데이터인지를 확인하고, 구조화된 데이터인 경우만 정상적으로 크롤링을 하고 색인을 만드는 과정을 거친다.그리고 사용자가 검색시, 구글 검색 사이트에서 검색 결과는 생성된 색인들 내에서 조회되는 과정을 거친다. 검색 엔진 최적화 (Search Engine Optimization, SEO)블로그 글을 작성하면서, 내가 작성한 글이 비슷한 고민을 하는 사람에게 노출되면 좋을 것 같다는 생각을 했다. 개인도 이러한데 특히 온라인 쇼핑몰이나 돈이 오가는 사이트의 경우, 사용자가 키워드로 검색시 상위에 노출되는 것이 매출과 직결될 것이다. 검색엔진최적화는 웹 페이지 검색엔진이 자료를 수집하고 순위를 매기는 방식에 맞게 웹 페이지를 구성해서 검색 결과의 상위에 나올 수 있도록 하는 작업을 말한다.-위키피디아: 검색 엔진 최적화- Semantic Web작성중 Schema.org작성중 JSON-LD작성중 결론Hexo와 Github을 이용해서 개발자 블로그를 만들면서 SEO (검색엔진최적화)란 용어를 처음 들었다. 구글, 네이버, 다음 검색사이트에 블로그를 노출하기 위했던 일들을 생각해보자. sitemap 또는 rss 생성 및 웹마스터 도구 등록 네이버는 rss2방식을 제공하기 때문에 추가함 robots.txt 생성 robots.txt 파일을 통해서 검색 사이트에서 크롤러가 작업을 할때 블로그에 크롤링 가능한 파일, 불가능 파일을 정리하고 거기에 따르도록 지시할 수 있다. 구글 같은 경우에는 크롤링이 실패할 경우, 새로 작성한 파일의 색인을 만들지 못하고, 변경한 글의 경우 이전에 작성한 내용이 노출되었다. 사내 시스템이나 B2B 사이트를 만들때는 전혀 생각하지 못했던 것들을 Hexo + Github으로 개발자 블로그를 만들면서 “SEO (검색엔진최적화)를 위한 Tip”을 알게 되서 의미있었다.Blog를 손쉽게 만들어주는 Hexo나 Jekyll 각각 마다 손쉽게 SEO를 적용할 있는 라이브러리들이 많았다. 블로그를 검색 사이트에 노출하기 위한 작업을 통해서 어떻게 검색사이트가 리소스들을 검색엔진에 노출시키는지 이해할 수 있었다. 참조 사이트 [Google Search Console - 파싱할 수 없는 구조화된 데이터 보고서] [JSON-LD 위키피디아 설] [Outsider님의 Schema.org로 웹 컨텐츠 조화하기 ]","categories":[{"name":"Blog","slug":"Blog","permalink":"http://gregor77.github.io/categories/Blog/"}],"tags":[{"name":"SEO","slug":"SEO","permalink":"http://gregor77.github.io/tags/SEO/"},{"name":"Google Search Console","slug":"Google-Search-Console","permalink":"http://gregor77.github.io/tags/Google-Search-Console/"},{"name":"Blog","slug":"Blog","permalink":"http://gregor77.github.io/tags/Blog/"},{"name":"구조화된 데이터","slug":"구조화된-데이터","permalink":"http://gregor77.github.io/tags/%EA%B5%AC%EC%A1%B0%ED%99%94%EB%90%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0/"},{"name":"Semantic Web","slug":"Semantic-Web","permalink":"http://gregor77.github.io/tags/Semantic-Web/"},{"name":"structure data","slug":"structure-data","permalink":"http://gregor77.github.io/tags/structure-data/"},{"name":"Schema.org","slug":"Schema-org","permalink":"http://gregor77.github.io/tags/Schema-org/"},{"name":"JSON-LD","slug":"JSON-LD","permalink":"http://gregor77.github.io/tags/JSON-LD/"},{"name":"검색엔진최적화","slug":"검색엔진최적화","permalink":"http://gregor77.github.io/tags/%EA%B2%80%EC%83%89%EC%97%94%EC%A7%84%EC%B5%9C%EC%A0%81%ED%99%94/"}]},{"title":"Unit Test (단위 테스트) 에 관한 생각","slug":"about-unit-test","date":"2019-08-16T02:27:10.000Z","updated":"2022-12-26T06:02:24.385Z","comments":true,"path":"2019/08/16/about-unit-test/","link":"","permalink":"http://gregor77.github.io/2019/08/16/about-unit-test/","excerpt":"","text":"지금 부서의 역할이 사내에서 제품을 가지고 있는 팀들과 협업을 하면서 기존에 문제를 해결하고 사용자 관점에서 더 가치있는 제품을 항상 딜리버리 가능한 상태로 만드는 것을 목표로 하고 있다.기존의 문제를 해결하는 방법으로 Agile의 Practice를 필요에 따라 활용하고 있으며, 특히 개발 Practice로는 TDD, Unit Test, Code Review, Pair Programming, CI&#x2F;CD 자동화, Build Monitor 등의 프랙티스를 가져간다. 개발자로서 프로젝트를 진행하면서 TDD까지 전파하는 것은 정말 어려운 일이고, TDD까지 가기전에 Unit Test 작성하는 것은 제1순위로 전파하려고 하는 편이다.테스트케이스 작성하는 방법을 체득화하고 그 이후에 TDD까지 이어가려고 하는데, 개발하는 습관이나 사고방식이 함께 바껴져야 하기 때문에 TDD까지 팀에 체득화 시키는 것은 항상 쉽지 않았다.TDD에 대해서는 할말이 너무 많지만, 이번 글은 Unit Test (단위 테스트)에 대해서 개인적인 글을 써보겠다. 단위 테스트 장점테스트케이스를 꼼꼼하게 작성을 하면서 내가 변경한 부분이 어디에 영향을 끼치는지 쉽게 파악할 수 있었다. 그 덕에 안심하고 리팩토링을 할 수 있는 점이 가장 좋았다.단위 테스트를 하지 않는다면 제대로 수정했는지 확인될때까지 로컬에서 확인을 했을 것이다. 만약 오류가 발생하면 디버깅을 통해서 확인하는 작업을 반복했을 것이다. 이렇게 소요되는 시간을 포함해서 생각해본다면 “단위테스트 작성때문에 생산성이 떨어지는 것은 아니냐?” 라는 의문에 대해서 그래도 얻는 장점이 더 많다고 말할 수 있지 않을까 생각한다. 단위 테스트 작성시 무엇이 좋았더냐? 테스트케이스가 꼼꼼하게 작성되어 있다면, 개발과정 중에 미리 문제를 파악할 수 있다. 코드변경시, 변경한 부분으로 인한 영향도를 쉽게 파악할 수 있다. 코드 리팩토링을 안심하고 할 수 있다. 테스트케이스들은 내가 가입한 보험들 같다. 테스트 자동화를 통해서 항상 딜리버리 가능한 제품을 만들 수 있다. 새로운 입력이 팀에 합류했을때, 개발 스타일, 표준, 컨벤션등을 공유하기에 좋다. 페어 프로그래밍을 할때, 테스트케이스 작성하고 개발하는 역할 핑퐁을 통해서 개발을 페어로 집중해서 진행할 수 있다. TDD + Pair Programming을 한다면, 테스트케이스 작성한 사람의 설계를 공유하면서 소스 개발까지 이어질 수 있으므로 집중력있게 개발할 수 있다. 테스트케이스에 대한 걱정기존에 단위 테스트를 작성하지 않는 개발자분들과 프로젝트를 할때, 공통적으로 듣는 질문이나 내용들이 있다. 그렇다면 질문에 대해서 하나씩 생각해보자.아직 해보지 않았거나 어떻게 해야할지 모르기 때문에 생각보다 두려움이 더 커져서 시도하기 어려울 수도 있다. 하지만 그 방법을 알거나 조금씩 해결할 수 있다면 단위 테스트를 적용할 수 있을 것이다. Q. 기존에 레거시 코드는 어떻게 해야하나?기존에 만들어진 코드에 모두 테스트 케이스를 만드는 것은 상당히 어렵다. 시간적인 여유가 팀원들이 함께 짤 수 있다면 시도를 해보는 것은 나쁘지 않다.하지만 이미 만들어진 코드의 규모가 크면 열정만으로는 다 커버하기가 쉽지 않다. 게다가 테스트 작성하는 법을 잘 모르고 있다면 익숙해지기 전까지 시간이 오래 걸린다.투자한 노력에 비해서 아직 커버해야하는 부분이 많이 남아있다는 것을 확인하는 순간 지칠수도 있다. 기존의 레거시 코드는 E2E 테스트로 커버한다. 새로 개발하거나 변경하는 부분을 대상으로 단위 테스트를 시작하라. 그렇게 하면 시간은 오래걸릴 수 있지만, 점차적으로 단위 테스트를 늘려갈 수 있을 것이다. E2E 테스트또한 기능이 복잡하거나 중요한 기능부터 커버하기 시작하라. 그렇다면 효율적으로 단위테스트 적용이 가능할 것이다. Q. 소스를 변경할때마다 단위테스트가 실패하면 유지보수 하는데 시간이 들지 않나?TDD(Test Driven Development, 테스트주도개발)의 라이프 사이클을 보면 테스트를 작성하고, 실패하는 것을 확인하고, 테스트가 통과하도록 고친다. 그이후에 리팩토링을 통해서 코드품질을 향상한다.이 과정을 반복을 하는데, 추가요건이 생기거나 리팩토링을 통해서 소스가 변경되어 단위 테스트가 실패하면 이를 고치는 것은 자연스러운 과정이다.물론 테스트를 유지보수하기 쉽게 작성하는 것이 중요하다. 어떻게 하면 유지보수하기 쉬운 테스트케이스를 작성할 수 있을까? 하나의 테스트에 하나의 기능만 검증하라. SRP (Single Responsibility Principle, 단일책임의원칙)을 객체지향 개발에서 중요한 원칙으로 생각한다. 이는 테스트 작성에도 도움이 된다고 생각한다. 이를 유의하면서 테스트케이스를 작성하면 테스트 케이스의 수직거리가 짧기 때문에 훨씬 간결해진다. 하나의 테스트케이스에서 너무 많은 기능을 검증하려고 하면, 중간에 깨졌을때 어떤부분 때문에 깨졌는지 확인하는데 시간이 오래 걸리는 부작용을 낳는다. 테스트케이스에서 반복되는 부분도 리팩토링을 하라. 테스트케이스를 짜다보면 반복되는 부분들이 발생한다. 예를 들면 특정 상황을 만들기 위해서 반복해서 Mock객체에 Stub을 통해서 의도한 결과를 만드는 것이 필요한 경우, 부모클래스나 메소드로 분리하면 테스트 작성자는 테스트 짜는 것에만 집중할 수 있다. Q. 작성하는 방법을 잘 모르는데 러닝커브가 크지 않나?초반에는 테스트케이스 작성하는 방법에 익숙하지 않기 때문에 분명히 시간이 든다. 테스트케이스 없이 개발할때 보다 시간이 더 오래 걸릴 것이다. 만약에 팀원들이아 리더가 코드 품질이나 테스트 케이스의 중요성에 대해서 인식하지 못하고 있다면 어떻게 해야할까?사실 그런 상황속에서 개인의 노력과 희생으로 익숙해질때까지 버티는 것은 쉽지않다. 최소한 같은 팀이라면 코드 품질과 테스트의 중요성은 공감하고 있어야 한다. 그래야 나중에라도 생산성이 떨어지는 것 아니냐 등의 볼멘소리가 나오지 않는다.Agile로 일하는 방식을 전파할때도 팀뿐만 아니라 리더들에게도 일하는 방식이나 사고방식의 변화의 중요성을 공유하는 이유가 그것 때문이다.테스트케이스 작성에 익숙해지면 그 이후부터는 대부분 비슷한 경우의 반복이 많으며, 테스트케이스 작성때문에 생산성이 떨어지는 상황은 크게 문제가 되지 않았다. 잘 작성된 테스트케이스는 사전과 같다. 나중에 기억이 잘 안나면 찾아보고 작성하면 된다. 단, 기존에 없었던 테스트를 작성해야 하는 상황에는 당연히 스파이킹 시간을 투자해야한다. 테스트케이스 자체가 문서라고 생각해보라. 물론 문서라는 것이 한번 만들고나면 현행화가 하는데 노력이 많이 들기도 하지만, 한번 만들어 놓으면 필요할때 찾아볼 수 있다. 단위 테스트 작성에 익숙한 사람과 덜 익숙한 사람과 **페어프로그래밍(Pair Programming)**을 진행해보라. 처음에는 익숙한 사람이 리딩을 하고, 그 이후에는 역할을 바꿔보며 페어로 진행하면 집중한 시간에 러닝커브를 가장 효율적으로 줄일 수 있다. 두 사람의 숙련도 차이가 너무 많이 나는 경우에는 차라리 교육으로 진행하는 것이 효율적이다. 도입하기단위테스트의 장점도 알았고, 경험해보지 못해서 생긴 두려움도 어떻게 극복할 수 있을지 이야기해보았다. 그렇다면 당장 어떻게 팀에 도입할 수 있을까?일단 팀원 모두가 공통적으로 필요성을 공감해야 지속할 수 있다. 기존에 프로젝트에 어떤 불편한점이 있었고, 단위테스트를 도입함으로써 어떻게 해결할 수 있을지 공감하고, 필요성을 느끼는 상태에서 시작해야 오래갈 수 있다.팀원에 한명이라도 부정적인 생각을 가지고 있다면, 그 사람은 테스트케이스 짜기를 앞으로도 꺼려해 누군가가 또 비는 곳을 채우는 상황들이 벌어질 수 있기 때문이다.기존에 작성하지 않는 팀이 도입하기 위해서는 어떤 변화가 필요할까? PM은 테스트케이스 작성에 개발자들이 익숙해지기까지 팀의 Velocity가 당장 떨어질 수 있다는 것을 인지해야 한다. 팀의 Velocity가 올라올때 까지 얼마나 걸릴지 확인해야하고, 그것을 감안해 일의 우선순의를 정리할 수 있어야 한다. 작성에 익숙해지면 그 이후부터는 개발하는 과정일 뿐이지 Velocity가 떨어지는 등의 일은 발생하지 않을 것이다. 테스트케이스 작성의 원칙, 범위, 작성방법을 정하고 시작한다. 개발자들마다 개발하는 스타일이 다 다를지라도, 소스의 유지보수를 위해서 표준, 코드 컨벤션 등의 스타일을 맞추는 작업을 진행한다. 테스트케이스의 유지보수를 위해서 얼마나 간결하게 작성을 할 것인지 범위를 정하는 것과 어떤 assertion이나 matcher 도구 등을 사용할지 정하고 가야 작성법이 단순해지기 전에 유지보수하기 편하다. (예: junit + hamcrest matcher vs assertJ) 테스트케이스 작성법이나 원칙은 계속 개선해나가는 것이 좋다. 단 변경될때마다 팀원들과 적극적으로 공유해야 테스트케이스 작성법을 비슷한 수준으로 유지할 수 있다. 단위테스트 작성원칙 하나의 테스트케이스에 최소한의 기능만 검증하고, 최대한 간결하게 짠다. 테스트케이스가 많은 것은 큰 문제가 되지 않는다. IDE 툴을 사용하면 테스트케이스가 많은 것은 쉽게 찾을 수 있다. [안티패턴] Java를 예를들면, 클래스에서 하나의 메소드를 하나의 테스트케이스를 기준으로 작성하는 경우를 본적이 있다. 분기문이 있거나 exception을 발생하는 경우가 다 하나의 테스트케이스에 포함되어 있다면 유지보수가 너무 어렵다. 소스를 변경해서 테스트케이스를 고치야 하는 경우, 테스트케이스를 이해하기위해서 시간을 많이 든다면 얼마나 비효율적인가? 유지보수하기 편하게 작성하는 것이 중요하다. 입력값에 대한 결과 값을 검증하는 방식으로 짜는 것이 기본이다. 입력값에 대한 결과값을 확인하는 방식으로 작성하면 소스가 변경되더라도 테스트케이스를 변경할 일이 훨씬 적다. 테스트케이스를 작성하다보면 구현체에 의존하지 않는 테스트케이스를 작성해야 유지보수가 쉽다. 하지만 단위테스트는 Mock객체를 사용하고 때로는 Stubbing도 해야되기 때문에 어느정도 구현체에 의존적일 수 밖에 없다.하지만 구현체에 의존적이지 않아야 유지보수 노력이 덜 든다. 항상 옳은 방법은 아닐 수 있지만, 기본적으로는 입력 값대비 결과값을 검증하는 방식으로 테스트케이스를 작성한다고 생각하면 쉽다. Java에서 단위 테스트에서 Private이나 Static method에 stub을 하기 위해 PowerMock을 사용하는 경우가 있다. 물론 File 관련 테스트를 작성하는 경우에 PowerMock이 도움이 된다.하지만 정말 복잡하거나 필요한 경우가 아니라면 PowerMock을 도입하는 것보다, 입력값에 대한 결과값을 확인하는 방식으로 작성하라. 불안한 부분이 없도록, 개발하는 부분은 최대한 커버하라. 우리가 개발하는 부분은 최대한 꼼꼼하게 작성해야 테스트케이스의 효과를 최대한 얻을 수 있다. 촘촘한 그물로 물고기를 많이 잡을 수 있는 것과 비슷하다. 커버리지는 꼼꼼하게 단위테스트를 작성하면 따라온다. 커버리지 수치 자체가 목적이 되어서는 안된다. Third Party Library의 기능은 믿고, 검증대상에서 제외하라. 효율적인 개발을 위해 적용한 라이브러리 또는 플러그인의 기능은 정상적으로 동작할거라 믿고 검증하지 않는다. 그럼에도 중요한 기능이고 테스트가 없어서 커버하지 못한다, Unit Test외에 Integration Test나 다른 테스트로 검증을 하는 것도 고려해본다. 예를들어, Spring에서 JPA, Mybatis 등을 사용하는데 Query의 기능을 검증하고 싶은 경우가 있다. 단위테스트를 위해 라이브러리 내부에서 동작하는 방식을 확인하면서 Mock객체로 바꾸고, Stub하는 과정은 상당히 괴롭다.이런 경우 Embedded DB나 Test DB를 대상으로 Repository Test 또는 Integration Test를 하는 것이 효율적이다. 단위테스트를 힘들게 드디어 팀에 도입했다. 시작이 반이라고는 하지만 이제부터가 진짜 중요하다. 어떻게 하면 힘들게 도입하게된 단위 테스트의 장점을 만끽하면서 지속할 수 있을까?테스트케이스를 작성하면서 개발을 시작했는데, 코드의 변경이 없어서 테스트케이스를 왜 작성해야하는지 모르겠다고 한다. 그냥 일만 두배로 하는 기분이고 이게 어떤 장점이 있는지 모르겠다고 한다.물론 기능이 동작하는 것이 가장 중요하지만, 한번 작성한 코드를 개선하는 노력없이 그대로 계속 둔다는 것은 충격적이다. 단위테스트를 지속하기 위한 방법Refactoring &#x3D; 지속하는 원동력개인적으로는 내가 작성한 코드가 되었던 내가 만드는 제품은 살아있는 생명체라 생각한다. 더 이상 관심을 두지않고, 그대로 둔다면 그냥 죽어있는 거다. 현실은 변경이 있을때마다 누더기처럼 덕지덕지 코드가 붙고, 그러다보니 기존에 만들어진 구조에서 최소한의 변경만 하려고 한다.이런 상황을 포장해서 고급스럽게(?) 레거시 프로그램이기 때문에 어쩔 수 없다고 말하는 사람들을 만나면 복잡한 생각이 든다. 리팩토링의 장점은 정말 크다고 생각한다. 내가 하고 있는 일, 내가 만드는 것들에 대해 가치를 불어넣어주는 중요한 행위라 생각한다. 리팩토링이 성공했다는 보장이 기존의 테스트케이스 통과이기 때문에, 꼼꼼한 테스트케이스가 있을수록 더 나은 코드로 개선할 수 있는 기회가 많다는 것이다.그래서 기존에 테스트케이스 효과를 경험하지 못한분들과 페어를 할 때는 유저스토리를 하나하면 리팩토링을 하나하는 순으로 일을 하려한다. 우리가 만든 코드를 개선하면서 바로 작성한 테스트케이스가 효과가 있는 것을 경험하는 과정이 말보다 훨씬 공감하기 좋은 방법이었다. 리팩토링을 습관화하기 위한 좋은 방법은 페어프로그래밍이 있지만 현실적 여건상 하기 어려운 곳들도 있다. 그런 경우에는 코드리뷰를 적용해보라. 코드리뷰를 통해서 더 나은 코드를 눈으로 보고, 내가 만드는 코드들이 더 나은 모습으로 개선될 수 있다는 것을 알게되면 자연스레 어느 정도의 코드품질을 지키기위해 리팩토링을 하게된다. 테스트 자동화테스트 자동화는 딜리버리 가능한 제품을 만들기 위해서는 선택이 아니라 필수다. 테스트 커버리지 측정, Report 생성해주는 라이브러리들, Sonar, Build Monitor를 이용해서 눈으로 우리가 만들고 있는 제품의 상황을 확인할 수 있다. 테스트케이스를 작성하는 목적보다 수치에 집착하는 것은 옳지 않다. 빌드 모니터의 목적은 눈으로 문제를 바로 확인할 수 있기 때문에, 가장 빠르게 대처하기 위함이다. 특히 사람은 눈에 보이는 것들에 민감하게 반응한다. 코드 커버리지나 코드 스멜, 보안성 취약점 등이 눈으로 확인되면 개선을 하려고 한다.그리고 한번 지켜지는 코드품질의 수준 이하로 내려가는 경우는 드물다. 결론이번 글은 개인적으로 프로젝트에 단위 테스트를 전파했던 경험들에 기반한 내용으로 개인적인 경험에 기반한 내용이라 부족하거나, 혹시 잘못된 생각이 있을 수도 있습니다. 처음에 단위테스트와 TDD를 프로젝트에서 하고 싶은데 방법을 몰라서 그만두게 된적이 몇번 있었다. 그 이후에 방법을 알고 싶어서 지금 부서에 와서 일을 하게 되었고, 이 글이 저와 비슷한 상황을 겪는 분들께 도움이 되었으면 합니다.지금의 저는 부족하면 더 많은 테스트케이스를 짜려고 합니다. 단위테스트로 부족하다고 생각이 들면 다른 테스트를 통해서 커버할 수 있는 방법이 있는지 고민합니다. 서비스를 만들다보면 소스가 자주 변화는 경우도 많고, 오늘의 나는 어제의 내가 짠 소스를 보면서 이해못하는 순간이 많습니다.그런 상황에서 믿을 것은 동료도 있지만 꼼꼼하게 작성한 테스트케이스가 큰 의지가 됩니다. 사람은 한번 더 편안한 것을 알게되면 이전에 구린방식으로 돌아가긴 어렵습니다. 제게 단위테스트가 그랬습니다. 만약에 이 글을 읽고 궁금한 점이 있으시면 댓글로 남겨주시면 확인하는대로 답변드리겠습니다.","categories":[{"name":"Unit Test & TDD","slug":"Unit-Test-TDD","permalink":"http://gregor77.github.io/categories/Unit-Test-TDD/"}],"tags":[{"name":"Unit test","slug":"Unit-test","permalink":"http://gregor77.github.io/tags/Unit-test/"},{"name":"단위테스트","slug":"단위테스트","permalink":"http://gregor77.github.io/tags/%EB%8B%A8%EC%9C%84%ED%85%8C%EC%8A%A4%ED%8A%B8/"},{"name":"Unit Test Anti Pattern","slug":"Unit-Test-Anti-Pattern","permalink":"http://gregor77.github.io/tags/Unit-Test-Anti-Pattern/"},{"name":"TDD","slug":"TDD","permalink":"http://gregor77.github.io/tags/TDD/"},{"name":"단위 테스트 실패","slug":"단위-테스트-실패","permalink":"http://gregor77.github.io/tags/%EB%8B%A8%EC%9C%84-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%8B%A4%ED%8C%A8/"}]},{"title":"Spring - 내가 짜는 Controller Test가 Hybrid Test?","slug":"spring-hybrid-test","date":"2019-08-13T10:24:31.000Z","updated":"2022-12-26T06:02:24.385Z","comments":true,"path":"2019/08/13/spring-hybrid-test/","link":"","permalink":"http://gregor77.github.io/2019/08/13/spring-hybrid-test/","excerpt":"","text":"Spring 기반에서 Controller 테스트를 작성시 요청을 보내고, 응답을 확인하는 형태로 많이 작성한다.그러다 보니 MockMvc나 jsonPath를 조합해서 Controller 테스트를 작성하는 경우가 많다.이번 포스팅은 MockMvc 기반의 Controller 테스트 작성방식을 다른 관점에서 볼 수 있는 경험담이다. 1. Hybrid Testing?Thought works에서 일하다 과거 같이 일하게 된 Kris가 프로젝트에 작성된 테스트케이스들에 대해 코드리뷰 해준 경험이 있다.기존의 Controller 테스트는 MockMvc를 이용해서 요청을 보내고 응답을 받는 방식으로 테스트 케이스를 작성하고 있었다.그런데 Kris가 너희가 짜고 있는 Controller 테스트는 Hybrid Test에 가깝다는 말을 했다.그리고 Controller 테스트를 pure한 Unit 테스트로 바꿔보는 것이 어떠겠냐고 제안을 했다. Hybrid Testing 정의Hybrid 테스트라는 단어를 들었을때, 단순히 어휘만 보고 뜻을 유추할 뿐 어떤 의미인지 정확하게 알지 못했다. 영어가 짧아 Kris와 깊은 대화를 하지 못했지만, 정의를 보고 어떤 의미에서 그렇게 말했는지 유추해보았다.첨부한 주소에 있는 내용을 기반으로 “Hybrid Testing”에 대해 정리를 해보았다. 하이브리드 테스트는 하향식 및 상향식 접근 방식의 장점을 사용하며, 테스트는 두 기술을 모두 사용해서 수행한다. 레이어 구성 &#x3D; 상위 레이어 + 기본 대상 레이어 + 하위 레이어 테스트는 중간 레벨 대상 계층에 중점을 두고 진행한다. 장점 개발주기의 초기 단계에서 기본적으로 동작하는 시스템을 만들수 있도록, 가능한 빨리 동작하는 버전의 프로그램을 테스트하고 싶은 경우 채택한다. 코드 커버리지의 정확성이 증가되고, 정기적인 시간 간격을 두고 최소의 테스트 케이스를 생성한다. 테스트할 내용 기능 테스트: 모든 기능이 예상대로 작동하는지 확인 호환성 테스트 연결 테스트: 응용 프로그램이 여러 유형의 네트워크 연결에서 올바르게 작동하는지 확인 2. Spring Controller TestSpring MVC에서 MockMvc를 이용하여 Controller 테스트를 작성하는 방식이 왜 Hybrid 테스트가 되는지 확인해보자. 테스트 범위 실제로 테스트를 하려고 하는 대상(subject)는 컨트롤러의 로직이다. 테스트를 동작방식이 상위 레이어를 통과하고, 하위 레이어를 다 통과해서 테스트를 한다. SpringRunner를 통해서 아래의 어노테이션과 함께 테스트를 수행한다 @SpringBootTest : 전체 Application Context 로드가 필요한 경우 @WebMvcTest: 컨트롤러에 필요한 Context만 필요한 경우 상위 레이어 Filter, Interceptor, DispatcherServlet 포함한 Front controller 수행 Request의 항목을 Object로 Deserialize 수행 하위 레이어를 거친 결과가 Response로 리턴 (response body, statusCode를 체크한다) 하위 레이어 Controller에서 호출하는 Service 또는 Repository를 포함한 DI(Dependency Injection)를 통해서 사용하는 Bean객체들은 @MockBean 어노테이션을 통해서 Mock 객체로 사용 필요한 경우 Mock 객체에 Method의 호출 결과를 의도한 결과로 동작하게끔 준비한다. (Stub &#x3D;&#x3D; canned answer) 장점 검증하고자 하는 부분은 Controller 로직이지만, API가 실제 동작하는 방식으로 체크를 하기 때문에 테스트 정확도가 더 높다. 개발단계에서 Test Case를 작성하고 수행함으로써 오류를 미리 파악하다.(여기서 미리 파악 가능하다는 것은, 로컬에서 어플리케이션을 수행하거나, 배포하기 전에 파악이 가능한 것을 의미한다) Functional Test 도입부르는 명칭이 조금씩 다르기는 했지만 Integration Test, API Test, Functional Test라 불렀던 것 같다.물론 각 명칭마다 조금씩 차이가 있을 수 있지만 동작방식은 API 요청을 보내고, 실제 비지니스 로직과 DB를 거친 결과를 확인하는 방식이다.Functional Test와 Unit Test는 작성하는 목적은 다르고, 지속하기 위해서는 상당한 노력이 필요하다. 데이터 유효성 처리 Embedded DB를 도입하던가 @Transactional을 통해 데이터 유효성을 유지하던가등 Unit Test를 작성할때 하지 않았던 것들을 고민해야한다. 쉽게 테스트 작성하기 MockMvc와 jsonPath를 이용해 Functional Test를 작성하기 위해서는 입력값과 결과값을 작성하기 번거롭다. 테스트를 지속적으로 작성하기 위해서는 작성이 쉬워야 하며, Functional Test의 경우 입력과 결과값을 최대한 단순하게 작성하는 것이 도움이 된다. Rest Assured를 개인적으로 추천한다. Request와 Response를 json 기반으로 작성이 가능하고, 그 기반으로 Response 검증이 가능하다. Functional Test vs Hybrid Controller Test팀의 성숙도와 상황에 따라 Controller Test를 어떻게 작성할 것인지 결정하면 될 것 같다.이는 개인적인 경험에 따른 판단이기 때문에 다른분과 의견이 다를 수도 있습니다. Hybrid Controller Test 언제 적합할까? 기존의 MockMvc를 통한 Controller Test 수행하면, 상위 레이어와 하위 레이어 검증이 가능하다. 팀의 규모가 작은 경우 팀의 테스트 케이스 작성 및 유지보수의 성숙도가 낮은 경우 비지니스 로직이 단순하거나, API의 값 검증의 가성비가 낮은 경우 기존의 테스트 방식으로 비슷한 효과를 낼 수 있기 때문에 유지하는 것이 현실적일 수 있다. Functional Test 도입 + Controller Test를 Unit Test로 변경은 언제 적합할까? Functional Test를 도입하면 상위 레이어의 기능 검증은 Functional Test로 위임이 가능하고,기존 Controller Test처럼 중복해서 검증할 필요없기 때문에 Pure한 Unit Test를 작성할 수 있다. 이말은 Controller 테스트또한 Service 테스트처럼, ApplicationContext를 생성할 필요없이 MockitoRunner를 이용해서 테스트 작성이 가능한 것을 의미한다. 실제 API의 결과를 검증하는 것이기 때문에 비지니스 로직과 DB를 거친 값을 검증한다. API의 비지니스 로직이 복잡하고, API의 값 검증이 중요한 경우 팀의 규모가 어느 정도되고, 테스트 케이스 작성 및 유지보수의 성숙도가 큰 경우 결론Kris의 제안대로 기존의 Controller Test 검증방식 중, 상위 레이어의 검증 대상을 Functional Test로 위임하고, 기존의 Controller 테스트를 Service 테스트처럼 작성하는 것이 옳은 것일까?결론은 테스트케이스를 작성하고 유지하는 팀의 성숙도에 따라 결정하면 될 것 같다. 또한 팀원들이기존의 테스트가 커버하지 못하는 부분이 있어 불안함과 부족함을 느낀다면 그때 시도해보는 것도 추천한다.","categories":[{"name":"Unit Test & TDD","slug":"Unit-Test-TDD","permalink":"http://gregor77.github.io/categories/Unit-Test-TDD/"},{"name":"Spring","slug":"Unit-Test-TDD/Spring","permalink":"http://gregor77.github.io/categories/Unit-Test-TDD/Spring/"}],"tags":[{"name":"Unit test","slug":"Unit-test","permalink":"http://gregor77.github.io/tags/Unit-test/"},{"name":"단위테스트","slug":"단위테스트","permalink":"http://gregor77.github.io/tags/%EB%8B%A8%EC%9C%84%ED%85%8C%EC%8A%A4%ED%8A%B8/"},{"name":"TDD","slug":"TDD","permalink":"http://gregor77.github.io/tags/TDD/"},{"name":"Spring","slug":"Spring","permalink":"http://gregor77.github.io/tags/Spring/"},{"name":"Controller Test","slug":"Controller-Test","permalink":"http://gregor77.github.io/tags/Controller-Test/"},{"name":"Hybrid Test","slug":"Hybrid-Test","permalink":"http://gregor77.github.io/tags/Hybrid-Test/"}]},{"title":"Hexo 기반의 Github 개발자 블로그 만들기","slug":"hexo-github-blog","date":"2019-08-12T01:58:31.000Z","updated":"2022-12-26T06:02:24.385Z","comments":true,"path":"2019/08/12/hexo-github-blog/","link":"","permalink":"http://gregor77.github.io/2019/08/12/hexo-github-blog/","excerpt":"","text":"Github으로 개발자 블로그를 생성하려고 하니 Hexo와 Jekyll 중에 어떤 툴을 사용해서 만들지 고민이었다.처음에는 Jekyll로 했는데 커스터마이징을 하려고하니 ruby보다는 javascript가 낫겠다 싶어 Hexo로 바꾸었다.둘다 사용해봤는데 둘다 장점은 비슷한 것 같고, 개인의 취향대로 하고 싶은 것을 선택하면 될 것 같다. Hexo 설치Hexo 설치후, 사용하고자 하는 themes를 선택한다.처음에는 landscape 테마를 선택했다가 comments, 찾기 기능이 있는 hueman 테마로 변경했다. 1234$ hexo init$ hexo new post &#123;post name&#125;$ hexo generate$ hexo deploy theme 적용하기 Hexo 사이트에 theme 메뉴에서 마음에 드는 테마를 선택 후, blog repository 내부로 새로운 theme를 clone12345$ git clone &#123;&#123;theme github repository 주소&#125;&#125; themes/&#123;&#123;새로운theme명&#125;&#125; 예)$ git clone https://github.com/ppoffice/hexo-theme-hueman.git themes/hueman _config.yml에서 theme 값 변경12themem: hueman 할일 구글 사이트 등록과 검색엔진 최적화 네이버 사이트 등록과 검색엔진 최적화 Open graph tag 적용 화면 update 배경 이미지 변경 사용하지 않는 메뉴 비활성화 (ex. NUBE DE TAGS) 참조 블로그블로그에 글이 너무 잘 작성되어 있어서, 아래 블로그를 따라하면서 적용함 Hexo document 구글 사이트 등록과 검색엔진 최적화(SEO) 네이버 사이트 등록과 검색엔진 최적화(SEO)","categories":[{"name":"Blog","slug":"Blog","permalink":"http://gregor77.github.io/categories/Blog/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://gregor77.github.io/tags/Hexo/"},{"name":"Github blog","slug":"Github-blog","permalink":"http://gregor77.github.io/tags/Github-blog/"},{"name":"SEO","slug":"SEO","permalink":"http://gregor77.github.io/tags/SEO/"},{"name":"Google Analytics","slug":"Google-Analytics","permalink":"http://gregor77.github.io/tags/Google-Analytics/"},{"name":"Google Search Console","slug":"Google-Search-Console","permalink":"http://gregor77.github.io/tags/Google-Search-Console/"}]},{"title":"Docker 개념과 실습","slug":"docker-basic","date":"2019-03-19T13:24:31.000Z","updated":"2022-12-26T06:02:24.385Z","comments":true,"path":"2019/03/19/docker-basic/","link":"","permalink":"http://gregor77.github.io/2019/03/19/docker-basic/","excerpt":"","text":"Docker 기초Docker에 대한 기본 설명과 Mac에서 실습을 진행하기 위한 글이다.마지막에 nginx.conf 설명이 있는 이유는, 프론트 소스를 빌드 결과를 nginx에 index.html 디렉토리 하위에 복사 후 nginx 도커 이미지 기반으로 app이 동작하는 것을 확인하는 것을 실습의 목표로 한다. VM vs Container vm은 OS가 동작하는데 필요한 기능들을 guest OS로 들고 있어야 한다. 용량이 크다. vm은 io가 발생하는 경로가 container보다 많다. vm이 처리한 io를 결국 host os의 커널이 받아 자신의 드라이버에 맞게 처리 필요하다. (병목 발생) container는 host의 os를 공유한다. Linux kernel featuresnamespaces mnt (파일시스템 마운트) : 호스트 파일 시스템에 구애받지 않고 독립적으로 파일 시스템을 마운트하거나 언마운트 가능 pid net : namespace간 네트워크 충돌 방지 (ex. 중복포트 바인딩) ipc : 프로세스간 독립적인 통신통로 할당 uts (hostname) user (UID) cgroup (Control groups)자원에 대한 제어를 가능하게 해준다. 메모리, CPU, I&#x2F;O, 네트워크, device 노드(&#x2F;dev) 장점 운영환경과 동일한 환경으로 개발환경 구성이 가능하다. Orchestration &#x3D;&gt; scale out MSA에 적합 Mac 환경설정 docker desktop app 설치 및 구동확인 (맥에서 가상화환경을 사용하기 위해 도커 엔진 설치)1234$ docker version# -i: tty 모드, -t: 대화형 세션, -h: host명$ docker exec -it redis bash Dockerfile 도커 이미지를 생성하기 위한 절차를 담고 있는 텍스트 파일 교육 중 진행한 sample 프로젝트를 docker 컨테이너로 실행해보자.123456789#Dockerfile: sample projectFROM nginx:alpineCOPY nginx.conf /etc/nginx/conf.d/default.confCOPY ./dist/ /usr/share/nginx/html#로컬에 image file 생성 [name]:[tag]$docker build -t sample . Docker image 여러 계층으로 구성되어 있다. 각 계층은 읽기 전용 파일 시스템에 있다. 계층은 도커파일에 있는 명령마다 생성되며, 이전 계층 위에 위치하게 된다.123456$docker images$docker rmi [이미지명]## UFS (유니온 파일 시스템, 유니온 마운트), 여러 개의 파일 시스템을 겹칠 수 있도록 해준다.$docker info | grep &quot;Storage Driver&quot; Docker Registry이미지를 운영하고 배포하는 역할을 담당하는 서비스, 기본 레지스트리 도커 허브 docker hub private registry Container123456789101112## 많이 사용하는 command 기준으로 설명$docker run -h sample-web -p 9080:80 -d sample$docker ps$docker stop [컨테이너명 | 컨테이너 ID]$docker ps -a$docker start [컨테이너명 | 컨테이너 ID]$docker rm [컨테이너명 | 컨테이너 ID] 참조 Docker와 VM Docker의 작동원리 What is Docker? Why you should use docker? 설정1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#nginx.confserver &#123; listen 80; server_name localhost; #charset koi8-r; #access_log /var/log/nginx/host.access.log main; location / &#123; if (!-e $request_filename)&#123; rewrite ^(.*)$ /index.html break; &#125; root /usr/share/nginx/html; index index.html index.htm; gzip_static on; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; location /api/v1 &#123; proxy_pass http://127.0.0.1:8088; &#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&#x27;s document root # concurs with nginx&#x27;s one # #location ~ /\\.ht &#123; # deny all; #&#125;&#125;","categories":[{"name":"Docker","slug":"Docker","permalink":"http://gregor77.github.io/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://gregor77.github.io/tags/Docker/"},{"name":"Docker 실습","slug":"Docker-실습","permalink":"http://gregor77.github.io/tags/Docker-%EC%8B%A4%EC%8A%B5/"}]}],"categories":[{"name":"React, FE","slug":"React-FE","permalink":"http://gregor77.github.io/categories/React-FE/"},{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"http://gregor77.github.io/categories/ElasticSearch/"},{"name":"Review","slug":"Review","permalink":"http://gregor77.github.io/categories/Review/"},{"name":"Spring security","slug":"Spring-security","permalink":"http://gregor77.github.io/categories/Spring-security/"},{"name":"Blog","slug":"Blog","permalink":"http://gregor77.github.io/categories/Blog/"},{"name":"Unit Test & TDD","slug":"Unit-Test-TDD","permalink":"http://gregor77.github.io/categories/Unit-Test-TDD/"},{"name":"Spring","slug":"Unit-Test-TDD/Spring","permalink":"http://gregor77.github.io/categories/Unit-Test-TDD/Spring/"},{"name":"Docker","slug":"Docker","permalink":"http://gregor77.github.io/categories/Docker/"}],"tags":[{"name":"React Testing Library, Unit Test, Jest","slug":"React-Testing-Library-Unit-Test-Jest","permalink":"http://gregor77.github.io/tags/React-Testing-Library-Unit-Test-Jest/"},{"name":"ElasticSearch, 검색엔진","slug":"ElasticSearch-검색엔진","permalink":"http://gregor77.github.io/tags/ElasticSearch-%EA%B2%80%EC%83%89%EC%97%94%EC%A7%84/"},{"name":"Jodit, Editor","slug":"Jodit-Editor","permalink":"http://gregor77.github.io/tags/Jodit-Editor/"},{"name":"인프라 엔지니어의 교과서","slug":"인프라-엔지니어의-교과서","permalink":"http://gregor77.github.io/tags/%EC%9D%B8%ED%94%84%EB%9D%BC-%EC%97%94%EC%A7%80%EB%8B%88%EC%96%B4%EC%9D%98-%EA%B5%90%EA%B3%BC%EC%84%9C/"},{"name":"요구사항 분석과 설계","slug":"요구사항-분석과-설계","permalink":"http://gregor77.github.io/tags/%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD-%EB%B6%84%EC%84%9D%EA%B3%BC-%EC%84%A4%EA%B3%84/"},{"name":"길벗","slug":"길벗","permalink":"http://gregor77.github.io/tags/%EA%B8%B8%EB%B2%97/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"http://gregor77.github.io/tags/Spring-Security/"},{"name":"인증 절차","slug":"인증-절차","permalink":"http://gregor77.github.io/tags/%EC%9D%B8%EC%A6%9D-%EC%A0%88%EC%B0%A8/"},{"name":"AuthenticationManager","slug":"AuthenticationManager","permalink":"http://gregor77.github.io/tags/AuthenticationManager/"},{"name":"ProviderManager","slug":"ProviderManager","permalink":"http://gregor77.github.io/tags/ProviderManager/"},{"name":"AuthenticationProvider","slug":"AuthenticationProvider","permalink":"http://gregor77.github.io/tags/AuthenticationProvider/"},{"name":"Authentication","slug":"Authentication","permalink":"http://gregor77.github.io/tags/Authentication/"},{"name":"UserDetailsService","slug":"UserDetailsService","permalink":"http://gregor77.github.io/tags/UserDetailsService/"},{"name":"Role","slug":"Role","permalink":"http://gregor77.github.io/tags/Role/"},{"name":"GrantedAuthority","slug":"GrantedAuthority","permalink":"http://gregor77.github.io/tags/GrantedAuthority/"},{"name":"Privilege","slug":"Privilege","permalink":"http://gregor77.github.io/tags/Privilege/"},{"name":"Spring security","slug":"Spring-security","permalink":"http://gregor77.github.io/tags/Spring-security/"},{"name":"SecurityContextHolder","slug":"SecurityContextHolder","permalink":"http://gregor77.github.io/tags/SecurityContextHolder/"},{"name":"Multi Thread","slug":"Multi-Thread","permalink":"http://gregor77.github.io/tags/Multi-Thread/"},{"name":"CountDownLatch","slug":"CountDownLatch","permalink":"http://gregor77.github.io/tags/CountDownLatch/"},{"name":"Unit Test","slug":"Unit-Test","permalink":"http://gregor77.github.io/tags/Unit-Test/"},{"name":"SW Engineering","slug":"SW-Engineering","permalink":"http://gregor77.github.io/tags/SW-Engineering/"},{"name":"C 언어","slug":"C-언어","permalink":"http://gregor77.github.io/tags/C-%EC%96%B8%EC%96%B4/"},{"name":"SEO","slug":"SEO","permalink":"http://gregor77.github.io/tags/SEO/"},{"name":"Google Search Console","slug":"Google-Search-Console","permalink":"http://gregor77.github.io/tags/Google-Search-Console/"},{"name":"Blog","slug":"Blog","permalink":"http://gregor77.github.io/tags/Blog/"},{"name":"구조화된 데이터","slug":"구조화된-데이터","permalink":"http://gregor77.github.io/tags/%EA%B5%AC%EC%A1%B0%ED%99%94%EB%90%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0/"},{"name":"Semantic Web","slug":"Semantic-Web","permalink":"http://gregor77.github.io/tags/Semantic-Web/"},{"name":"structure data","slug":"structure-data","permalink":"http://gregor77.github.io/tags/structure-data/"},{"name":"Schema.org","slug":"Schema-org","permalink":"http://gregor77.github.io/tags/Schema-org/"},{"name":"JSON-LD","slug":"JSON-LD","permalink":"http://gregor77.github.io/tags/JSON-LD/"},{"name":"검색엔진최적화","slug":"검색엔진최적화","permalink":"http://gregor77.github.io/tags/%EA%B2%80%EC%83%89%EC%97%94%EC%A7%84%EC%B5%9C%EC%A0%81%ED%99%94/"},{"name":"Unit test","slug":"Unit-test","permalink":"http://gregor77.github.io/tags/Unit-test/"},{"name":"단위테스트","slug":"단위테스트","permalink":"http://gregor77.github.io/tags/%EB%8B%A8%EC%9C%84%ED%85%8C%EC%8A%A4%ED%8A%B8/"},{"name":"Unit Test Anti Pattern","slug":"Unit-Test-Anti-Pattern","permalink":"http://gregor77.github.io/tags/Unit-Test-Anti-Pattern/"},{"name":"TDD","slug":"TDD","permalink":"http://gregor77.github.io/tags/TDD/"},{"name":"단위 테스트 실패","slug":"단위-테스트-실패","permalink":"http://gregor77.github.io/tags/%EB%8B%A8%EC%9C%84-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%8B%A4%ED%8C%A8/"},{"name":"Spring","slug":"Spring","permalink":"http://gregor77.github.io/tags/Spring/"},{"name":"Controller Test","slug":"Controller-Test","permalink":"http://gregor77.github.io/tags/Controller-Test/"},{"name":"Hybrid Test","slug":"Hybrid-Test","permalink":"http://gregor77.github.io/tags/Hybrid-Test/"},{"name":"Hexo","slug":"Hexo","permalink":"http://gregor77.github.io/tags/Hexo/"},{"name":"Github blog","slug":"Github-blog","permalink":"http://gregor77.github.io/tags/Github-blog/"},{"name":"Google Analytics","slug":"Google-Analytics","permalink":"http://gregor77.github.io/tags/Google-Analytics/"},{"name":"Docker","slug":"Docker","permalink":"http://gregor77.github.io/tags/Docker/"},{"name":"Docker 실습","slug":"Docker-실습","permalink":"http://gregor77.github.io/tags/Docker-%EC%8B%A4%EC%8A%B5/"}]}